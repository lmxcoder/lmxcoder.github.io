<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Moench 的算法宝库</title><meta name="author" content="Moench"><meta name="copyright" content="Moench"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="万物静默如迷，时间就是谜底。">
<meta property="og:type" content="website">
<meta property="og:title" content="Moench 的算法宝库">
<meta property="og:url" content="https://lmxcoder.github.io/page/2/index.html">
<meta property="og:site_name" content="Moench 的算法宝库">
<meta property="og:description" content="万物静默如迷，时间就是谜底。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lmxcoder.github.io/myimages/my.jpg">
<meta property="article:author" content="Moench">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lmxcoder.github.io/myimages/my.jpg"><link rel="shortcut icon" href="/myimages/favicon-16x16.png"><link rel="canonical" href="https://lmxcoder.github.io/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Moench","link":"链接: ","source":"来源: Moench 的算法宝库","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Moench 的算法宝库',
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2022-11-21 23:57:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myimages/my.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/myimages/%E7%AC%A6%E5%8D%8E%E5%92%8C%E8%AF%86%E5%BE%8B.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Moench 的算法宝库</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Moench 的算法宝库</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/lmxcoder" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/posts/a72d76aa/" title="Prim算法"><img class="post_bg" src="/myimages/%E7%AC%A6%E5%8D%8E%E6%A3%AE%E7%BB%BF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Prim算法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/a72d76aa/" title="Prim算法">Prim算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-14T08:55:58.000Z" title="发表于 2022-11-14 16:55:58">2022-11-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/prim%E7%AE%97%E6%B3%95/">prim算法</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/prim%E7%AE%97%E6%B3%95/">prim算法</a></span></div><div class="content">Prim算法时间复杂度：
O(n^2 + m)

具体实现：
邻接矩阵存边的权值
距离初始化为正无穷
每次选择当前集合终和外界所连边的权值最小的点
将该边所连的点扩展，并用刚扩展的点更新其他点到当前集合的权值

算法证明：
证明思路与kruskal算法类似。
如何证明这条边一定可以被选？
假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会形成一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差。


证明结论：当前与外界直接相连的权值最小的一条边，这条边一定可以出现在最优解中。
证明过程如下：
反证法：假设选择最小生成树的某一个状态集合x扩展某一个边x1(最小)时没有选择该边，选择了另一个边x2(非最小)，从而形成了一个生成树。
证明：已知集合x可扩展多个边x1, x2……x’等(权值升序排列)，选择了x2边扩展。若将x1边加入扩展了x2边而最终形成的生成树中，则必定会形成一个环，且该环上一定包含x’这条边，因为x1为扩展出来的权值最小的边，x’等其他边时扩展出来的非权值第一小边，则将x’去掉，x1加上，形成的还是一个生成树，且该 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/2b475c23/" title="Floyd思想和倍增思想"><img class="post_bg" src="/myimages/%E6%9D%8E%E7%B4%A0%E8%A3%B3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Floyd思想和倍增思想"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/2b475c23/" title="Floyd思想和倍增思想">Floyd思想和倍增思想</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-13T16:45:24.000Z" title="发表于 2022-11-14 00:45:24">2022-11-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/Floyd%E6%80%9D%E6%83%B3%E5%92%8C%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3/">Floyd思想和倍增思想</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/floyd/">floyd</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%80%8D%E5%A2%9E/">倍增</a></span></div><div class="content">Floyd思想和倍增思想例题：345.牛站
时间复杂度：
O(n^3*logm)

算法思路：
Floyd思想：
状态表示：d[K][i][j]为从i到j的经过前K条边的路径的最小值(与Floyd的d[n][i][j]经过前n个点的表示方法略有不同)
状态计算：d[K][i][j] = d[a][i][k] + d[b][k][j]，其中k为经过前a条边后的点，
更新一次可以增加两条边，更新两次增加三条边，如此我们仅需更新m-1次即可得到d[m][S][E]，时间复杂度为：O(n^3*m) n为200，m为1e6必定TLE
可以用倍增思想来将时间复杂度化为logm


倍增思想(快速幂思想)
最终路径类似于：S-&gt;x1-&gt;x2-&gt;x3-&gt;……-&gt;……-&gt;xm-1-&gt;E, 中间经过了m-1个点，m条边
我们可发现上述的路径先计算与后计算不会相互影响，即可以先计算中间的或先计算后面的，具有结合律，如此可借助倍增思想，仅需logm次即可找到合法路径
时间复杂度：O(n^3*logm)



具体实现：
哈希所有用过的点，包括起点和终点
倍增算法

代 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/20aed843/" title="Floyd算法求最小环"><img class="post_bg" src="/myimages/%E9%80%90%E7%81%AB%E5%8D%81%E4%B8%89%E8%8B%B1%E6%A1%80.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Floyd算法求最小环"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/20aed843/" title="Floyd算法求最小环">Floyd算法求最小环</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-13T14:03:32.000Z" title="发表于 2022-11-13 22:03:32">2022-11-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/Floyd%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF/">Floyd算法求最小环</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/floyd/">floyd</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98/">最小环问题</a></span></div><div class="content">Floyd 算法求最小环算法思路
DP思路
状态表示：化整为零：按照环上的最大点的编号来分类，可保证不重不漏
状态计算：枚举和最大点相邻的两点i,j同时使得dist[i][j]距离最小，即可保证最小环i-&gt;k-&gt;j-&gt;i的权值最小


证明算法步骤2的正确性：
若枚举到最大点k时，按照如上所述的方法找到最小环上的一个点大于k看，假设为k+2，则我们在该点k处用所有小于k的点i,j找到的最小环，一定不是全局的最优解，当我们枚举到 k+2 时，方可枚举到全局最小换，反证成立，则算法成立



具体实现
每次floyd更新最外层的k时，已知的路径中，只含0~k-1这些点更新的路径，如此可求得环上的最大值为k时的最小环。
求最小环权值：枚举与k相邻的i,j(小于k)，使dist[i][j]最小，即为环上最大点为k的最小环的权值，依次更新k直到k等于n，算法结束
求最小环路径：记录pos[i][j]为 [i, j] 区间，是由pos[i][j]更新而来，每次更新答案，递归求解路径

代码如下：1234567891011121314151617181920212223242526 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/39d70f23/" title="传递闭包"><img class="post_bg" src="/myimages/%E9%9B%B7%E5%BE%8B_%E5%85%AB%E9%87%8D%E6%A8%B1_%E7%88%B1%E4%B8%BD%E5%B8%8C%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传递闭包"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/39d70f23/" title="传递闭包">传递闭包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-13T13:37:28.000Z" title="发表于 2022-11-13 21:37:28">2022-11-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/">传递闭包</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/floyd/">floyd</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/">传递闭包</a></span></div><div class="content">传递闭包时间复杂度：
O(n^3)

算法解释：若 a-&gt;b, b-&gt;c 则 a-&gt;c，将所有的间接到的点化为直接到，如此称为传递闭包算法思路
直接Floyd算法
更新距离的函数变一下即可

代码如下：1234567891011121314151617181920212223void floyd()&#123;    memcpy(d, g, sizeof d);        for (int k = 0; k &lt; n; k ++ )        for (int i = 0; i &lt; n; i ++ )            for (int j = 0; j &lt; n; j ++ )                d[i][j] |= d[i][k] &amp; d[k][j];&#125;int main()&#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/1e2a4971/" title="最短路求方案数"><img class="post_bg" src="/myimages/%E9%98%BF%E6%B3%A2%E5%B0%BC%E4%BA%9A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最短路求方案数"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/1e2a4971/" title="最短路求方案数">最短路求方案数</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-11T07:21:13.000Z" title="发表于 2022-11-11 15:21:13">2022-11-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/%E6%96%B9%E6%A1%88%E6%95%B0/">方案数</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%96%B9%E6%A1%88%E6%95%B0/">方案数</a></span></div><div class="content">最短路求方案数整体思路：
首先引入拓扑序的概念：计算当前状态时，当前状态所依赖的状态都已经计算出来了
类似DP，先求出全局最小值，再分别求出每个子集中等于全局最小值的元素数量，和最短路的唯一区别是，DP是在拓扑图中做最短路，但普通的最短路中可能存在环
若将最短路的模型转化为拓扑图，则可以用类似DP的方式处理求方案数的问题
其次引入最短路树（最短路拓扑图）
概念：记录每个点是由哪个点更新来的，即若 dist[j] = dist[t] + w[i] (t -&gt; j)，j 可由 t 更新而来。
如果没有任何限制，则可能存在权值为0的环，可以在此环上转无限次，则最短路径的方案数为 INF，相当于无解了，求不出确切的树。
所以，如果想要求最短路的方案数，则图中不能存在权值为0的环，依照上述方案记录路径，即可形成拓扑图，简单地说，将可以求最短路时可以被利用的边保存（可更新最短路径上的点的边保存），其余边去掉。



分析算法：求最短路的算法系列：
热知识：判断是否满足拓扑序，此点不能更新之前已更新的点，反之则形成环，非拓扑序

BFS系列（bfs）
一层一层扩展，保证每个点只入队一次，且只出 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/88e344b2/" title="双端队列广搜"><img class="post_bg" src="/myimages/8-bits.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="双端队列广搜"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/88e344b2/" title="双端队列广搜">双端队列广搜</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-09T06:17:46.000Z" title="发表于 2022-11-09 14:17:46">2022-11-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%90%9C%E7%B4%A2/">搜索</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E6%90%9C%E7%B4%A2/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C/">双端队列广搜</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C/">双端队列广搜</a></span></div><div class="content">双端队列广搜时间复杂度；
每次从队列中取出队头为 $O(1)$
整体时间复杂度为线性的，即 $O(n + m)$

适用场景
边权仅为0或1的图中

算法模板(整体思路类似堆优化 $dijkstra$ 算法)
12345678910111213141516171819202122232425262728void bfs()&#123;    memset(dist, 0x3f, sizeof dist);    memset(st, 0, sizeof st);    dist[1] = 0;    q.push_front(1);        while(q.size())    &#123;        // 每次取出队头，时间复杂度O(1)        auto t = q.front();        q.pop_front();                if(st[t]) continue;        st[t] = true;                for (int i = h[t]; ~i; i = ne[i])        &#123;    ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/bc46f58a/" title="朴素 dijkstra 算法"><img class="post_bg" src="/myimages/%E4%B8%80%E8%A1%8C_%E6%94%B9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="朴素 dijkstra 算法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/bc46f58a/" title="朴素 dijkstra 算法">朴素 dijkstra 算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-08T06:35:38.000Z" title="发表于 2022-11-08 14:35:38">2022-11-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/%E6%9C%B4%E7%B4%A0-Dijkstra-%E7%AE%97%E6%B3%95/">朴素 Dijkstra 算法</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/dijkstra/">dijkstra</a></span></div><div class="content">朴素 Dijkstra 算法时间复杂度
$O(n^2)$

算法应用情景：
不含有负权边的图中

整体思路：
初始化，将起点加入已更新的点中，并将起点的 dist 设为 0，其余点的 dist 为 INF，代表没更新
循环 n - 1 次，每次更新一个点，
用这个点更新其他点到起点的距离

如图所示：
模板代码如下：1234567891011121314151617181920212223242526272829int g[N][N];  // 邻接矩阵，存储每条边int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;     // 先选中一个点，剩余 n - 1 个点，迭代 n - 1 次    for (int i = 0; i &lt; n - 1; i ++ )    &#123;        int t =  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/d3e5ea48/" title="Test01"><img class="post_bg" src="/myimages/%E7%8C%AB%E7%8C%AB2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Test01"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/d3e5ea48/" title="Test01">Test01</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-07T16:25:23.000Z" title="发表于 2022-11-08 00:25:23">2022-11-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">排序</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BA%8C%E5%88%86/">二分</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/BFS/">BFS</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/DFS/">DFS</a></span></div><div class="content">跳转到B站
测试的文章一级标题二级标题三级标题四级标题五级标题六级标题
BP算法
训练集    $\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}$
设    $\Delta_{i j}^{(l)}=0(\text { for all } l, i, j)$
$\begin{array}{l}{\text {For } i=1 \text { to } m}\end{array}$

\begin{array}{l}{\text { Set } a^{(1)}=x^{(i)}} \\ {\text { Perform forward propagation to compute } a^{(l)} \text { for } l=2,3, \ldots, L} \\ {\text { Using } y^{(i)}, \text { compute } \delta^{(L)}=a^{(L)}-y^{(i)}} \\ {\text { Compute } \delta^{ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/4a17b156/" title="Hello World"><img class="post_bg" src="/myimages/%E7%AC%A6%E5%8D%8E%E5%92%8C%E8%AF%86%E5%BE%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/4a17b156/" title="Hello World">Hello World</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-07T15:28:49.110Z" title="发表于 2022-11-07 23:28:49">2022-11-07</time></span></div><div class="content">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;
More info: Writing
Run server1$ hexo server
More info: Server
Generate static files1$ hexo generate
More info: Generating
Deploy to remote sites1$ hexo deploy
More info: Deployment
</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/myimages/my.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Moench</div><div class="author-info__description">万物静默如迷，时间就是谜底。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lmxcoder"><i class="fab fa-github"></i><span>My github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lmxcoder" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog, please praise more and criticize less !</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/973bc934/" title="二分图"><img src="/myimages/%E5%B8%85%E7%AC%A6%E5%8D%8E2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二分图"/></a><div class="content"><a class="title" href="/posts/973bc934/" title="二分图">二分图</a><time datetime="2022-11-21T08:47:37.000Z" title="发表于 2022-11-21 16:47:37">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b8105b5b/" title="无向图的双连通分量(DCC)"><img src="/myimages/%E5%B8%85%E7%AC%A6%E5%8D%8E.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无向图的双连通分量(DCC)"/></a><div class="content"><a class="title" href="/posts/b8105b5b/" title="无向图的双连通分量(DCC)">无向图的双连通分量(DCC)</a><time datetime="2022-11-19T14:17:42.000Z" title="发表于 2022-11-19 22:17:42">2022-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/31194034/" title="有向图的强连通分量"><img src="/myimages/HELLO-WORLD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有向图的强连通分量"/></a><div class="content"><a class="title" href="/posts/31194034/" title="有向图的强连通分量">有向图的强连通分量</a><time datetime="2022-11-18T08:16:00.000Z" title="发表于 2022-11-18 16:16:00">2022-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eaed4358/" title="最近公共祖先(LCA问题)"><img src="/myimages/%E4%BA%BA%E5%BE%8B1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最近公共祖先(LCA问题)"/></a><div class="content"><a class="title" href="/posts/eaed4358/" title="最近公共祖先(LCA问题)">最近公共祖先(LCA问题)</a><time datetime="2022-11-17T10:46:29.000Z" title="发表于 2022-11-17 18:46:29">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/417dcd30/" title="差分约束"><img src="/myimages/%E8%AF%86%E5%AE%9D.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="差分约束"/></a><div class="content"><a class="title" href="/posts/417dcd30/" title="差分约束">差分约束</a><time datetime="2022-11-16T14:35:11.000Z" title="发表于 2022-11-16 22:35:11">2022-11-16</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="card-category-list-name">图论</span><span class="card-category-list-count">15</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"><span class="card-category-list-name">01分数规划</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/Floyd%E6%80%9D%E6%83%B3%E5%92%8C%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3/"><span class="card-category-list-name">Floyd思想和倍增思想</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/Floyd%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF/"><span class="card-category-list-name">Floyd算法求最小环</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/SPFA%E6%B1%82%E8%B4%9F%E7%8E%AF/"><span class="card-category-list-name">SPFA求负环</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"><span class="card-category-list-name">二分图</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"><span class="card-category-list-name">传递闭包</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"><span class="card-category-list-name">差分约束</span><span class="card-category-list-count">1</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/floyd/" style="font-size: 1.45em; color: rgb(85, 92, 95)">floyd</a><a href="/tags/%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98/" style="font-size: 1.15em; color: rgb(187, 27, 124)">最小环问题</a><a href="/tags/%E5%80%8D%E5%A2%9E/" style="font-size: 1.15em; color: rgb(152, 137, 188)">倍增</a><a href="/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/" style="font-size: 1.15em; color: rgb(123, 102, 190)">01分数规划</a><a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 1.3em; color: rgb(82, 35, 181)">最小生成树</a><a href="/tags/kruskal%E7%AE%97%E6%B3%95/" style="font-size: 1.15em; color: rgb(179, 120, 133)">kruskal算法</a><a href="/tags/prim%E7%AE%97%E6%B3%95/" style="font-size: 1.15em; color: rgb(140, 42, 55)">prim算法</a><a href="/tags/spfa/" style="font-size: 1.15em; color: rgb(18, 132, 65)">spfa</a><a href="/tags/%E8%B4%9F%E7%8E%AF/" style="font-size: 1.15em; color: rgb(197, 77, 156)">负环</a><a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 1.15em; color: rgb(157, 124, 137)">排序</a><a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 1.15em; color: rgb(63, 193, 39)">二分</a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 1.15em; color: rgb(70, 164, 93)">双指针</a><a href="/tags/BFS/" style="font-size: 1.15em; color: rgb(1, 11, 6)">BFS</a><a href="/tags/DFS/" style="font-size: 1.15em; color: rgb(56, 53, 68)">DFS</a><a href="/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/" style="font-size: 1.15em; color: rgb(185, 112, 112)">传递闭包</a><a href="/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/" style="font-size: 1.15em; color: rgb(76, 164, 99)">差分约束</a><a href="/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C/" style="font-size: 1.15em; color: rgb(9, 115, 161)">双端队列广搜</a><a href="/tags/%E6%96%B9%E6%A1%88%E6%95%B0/" style="font-size: 1.15em; color: rgb(123, 180, 88)">方案数</a><a href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 1.15em; color: rgb(43, 20, 110)">最近公共祖先</a><a href="/tags/LCA/" style="font-size: 1.15em; color: rgb(58, 57, 186)">LCA</a><a href="/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size: 1.15em; color: rgb(149, 199, 130)">有向图的强连通分量</a><a href="/tags/dijkstra/" style="font-size: 1.15em; color: rgb(195, 82, 49)">dijkstra</a><a href="/tags/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 1.15em; color: rgb(196, 51, 5)">次小生成树</a><a href="/tags/%E5%BA%94%E8%AF%95%E6%8A%80%E5%B7%A7/" style="font-size: 1.15em; color: rgb(111, 22, 104)">应试技巧</a><a href="/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size: 1.15em; color: rgb(161, 123, 139)">无向图的双连通分量</a><a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 1.15em; color: rgb(141, 180, 158)">二分图</a><a href="/tags/%E6%9F%93%E8%89%B2%E6%B3%95/" style="font-size: 1.15em; color: rgb(9, 39, 25)">染色法</a><a href="/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/" style="font-size: 1.15em; color: rgb(103, 6, 192)">匈牙利算法</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/11/"><span class="card-archive-list-date">十一月 2022</span><span class="card-archive-list-count">19</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">19</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-11-09T15:50:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">16.9k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-11-21T15:57:05.518Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Moench</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
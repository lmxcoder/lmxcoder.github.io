<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test01</title>
    <url>/2022/11/08/Test01/</url>
    <content><![CDATA[<p><a href="http://www.bilibili.com/">跳转到B站</a></p>
<h1 id="测试的文章"><a href="#测试的文章" class="headerlink" title="测试的文章"></a>测试的文章</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<p><strong>BP算法</strong></p>
<p>训练集    $\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}$</p>
<p>设    $\Delta_{i j}^{(l)}=0(\text { for all } l, i, j)$</p>
<p>$\begin{array}{l}{\text {For } i=1 \text { to } m}\end{array}$</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\text { Set } a^{(1)}=x^{(i)}} \\ {\text { Perform forward propagation to compute } a^{(l)} \text { for } l=2,3, \ldots, L} \\ {\text { Using } y^{(i)}, \text { compute } \delta^{(L)}=a^{(L)}-y^{(i)}} \\ {\text { Compute } \delta^{(L-1)}, \delta^{(l+1)}, \ldots, \delta^{(2)}} \\ {\Delta_{i j}^{(l)} :=\Delta_{i j}^{(l)}+a_{j}^{(l)} \delta_{i}^{(l+1)}}\end{array}</script><p>$\begin{array}{l}{D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}+\lambda \Theta_{i j}^{(l)}} &amp; {\text { if } j \neq 0} \\ {D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}} &amp; {\text { if } j=0}\end{array}$</p>
<p>其中    $\frac{\partial}{\partial \Theta_{i j}^{(l)}} J(\Theta)=D_{i j}^{(l)}$</p>
<hr>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>二分</tag>
        <tag>双指针</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>双端队列广搜</title>
    <url>/2022/11/09/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%B9%BF%E6%90%9C/</url>
    <content><![CDATA[<h1 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h1><h2 id="时间复杂度；"><a href="#时间复杂度；" class="headerlink" title="时间复杂度；"></a>时间复杂度；</h2><ul>
<li>每次从队列中取出队头为 $O(1)$</li>
<li>整体时间复杂度为线性的，即 $O(n + m)$</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>边权仅为0或1的图中</li>
</ul>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><p>(整体思路类似堆优化 $dijkstra$ 算法)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次取出队头，时间复杂度O(1)</span></span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!v) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>类似堆优化 $dijkstra$ 算法，因为边权只有0和1，可以将0插入队头，1插入队尾，可以保证单调性的同时，将从优先队列中取出最小值的 $O(logm)$ 的步骤，优化为只取出队头的 $O(1)$ 操作，从而将时间复杂度降低为线性</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
        <category>双端队列广搜</category>
      </categories>
      <tags>
        <tag>双端队列广搜</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>朴素 $dijkstra$ 算法</title>
    <url>/2022/11/08/%E6%9C%B4%E7%B4%A0dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="朴素-Dijkstra-算法"><a href="#朴素-Dijkstra-算法" class="headerlink" title="朴素 $Dijkstra$ 算法"></a>朴素 $Dijkstra$ 算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>$O(n^2)$</li>
</ul>
<h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><ul>
<li>初始化，将起点加入已更新的点中，并将起点的 <code>dist</code> 设为 0，其余点的 <code>dist</code> 为 INF，代表没更新</li>
<li>循环 <code>n - 1</code> 次，每次更新一个点，</li>
<li>用这个点更新其他点到起点的距离</li>
</ul>
<h2 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h2><p><img src="https://img-blog.csdnimg.cn/0921267586bb431fab5bc2e42a854077.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pm0X-aYjg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="朴素 $Dijkstra$ 算法"></p>
<h2 id="模板代码如下："><a href="#模板代码如下：" class="headerlink" title="模板代码如下："></a>模板代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 邻接矩阵，存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 先选中一个点，剩余 n - 1 个点，迭代 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"> </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体证明："><a href="#具体证明：" class="headerlink" title="具体证明："></a>具体证明：</h2>]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>朴素 $Dijkstra$</category>
      </categories>
      <tags>
        <tag>$dijkstra$</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01分数规划</title>
    <url>/posts/40edd48c/</url>
    <content><![CDATA[<h1 id="01分数规划"><a href="#01分数规划" class="headerlink" title="01分数规划"></a>01分数规划</h1><p>例题：<a href="https://www.acwing.com/problem/content/363/">spfa求负环 + 01分数规划</a></p>
<p>可参考如下博客：<a href="https://oi-wiki.org/misc/frac-programming/">分数规划</a></p>
<h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><ul>
<li>(一堆和) / (一堆和) 使其结果最大</li>
</ul>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ul>
<li>二分 [l, r]</li>
<li>f的和 / t的和 &gt; mid =&gt; f的和 &gt; mid <em> t的和 =&gt; (f[i] - mid </em> t[i])的和 &gt; 0 </li>
<li>最终 等价于图中是否存在正环？</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> wf[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], wt[M], ne[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + wf[t] - mid * wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + wf[t] - mid * wt[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        cin &gt;&gt; wf[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>01分数规划</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法求最小环</title>
    <url>/posts/20aed843/</url>
    <content><![CDATA[<h2 id="Floyd-算法求最小环"><a href="#Floyd-算法求最小环" class="headerlink" title="Floyd 算法求最小环"></a>Floyd 算法求最小环</h2><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>DP思路<ul>
<li>状态表示：化整为零：按照环上的最大点的编号来分类，可保证不重不漏</li>
<li>状态计算：枚举和最大点相邻的两点i,j同时使得dist[i][j]距离最小，即可保证最小环i-&gt;k-&gt;j-&gt;i的权值最小</li>
</ul>
</li>
<li>证明算法步骤2的正确性：<ul>
<li>若枚举到最大点k时，按照如上所述的方法找到最小环上的一个点大于k看，假设为k+2，则我们在该点k处用所有小于k的点i,j找到的最小环，一定不是全局的最优解，当我们枚举到 k+2 时，方可枚举到全局最小换，反证成立，则算法成立</li>
</ul>
</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>每次floyd更新最外层的k时，已知的路径中，只含0~k-1这些点更新的路径，如此可求得环上的最大值为k时的最小环。</li>
<li>求最小环权值：枚举与k相邻的i,j(小于k)，使dist[i][j]最小，即为环上最大点为k的最小环的权值，依次更新k直到k等于n，算法结束</li>
<li>求最小环路径：记录pos[i][j]为 [i, j] 区间，是由pos[i][j]更新而来，每次更新答案，递归求解路径</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> path[N], pos[N][N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = pos[l][r];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_path</span>(l, k);</span><br><span class="line">    path[cnt ++ ] = k;</span><br><span class="line">    <span class="built_in">get_path</span>(k, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((LL)d[i][j] + g[j][k] + g[k][i] &lt; res) <span class="comment">// i-&gt;k-&gt;j</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res = d[i][j] + g[j][k] + g[k][i];</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    path[cnt ++ ] = k;</span><br><span class="line">                    path[cnt ++ ] = i;</span><br><span class="line">                    <span class="built_in">get_path</span>(i, j);</span><br><span class="line">                    path[cnt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>Floyd算法求最小环</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>最小环问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd思想和倍增思想</title>
    <url>/posts/2b475c23/</url>
    <content><![CDATA[<h1 id="Floyd思想和倍增思想"><a href="#Floyd思想和倍增思想" class="headerlink" title="Floyd思想和倍增思想"></a>Floyd思想和倍增思想</h1><p>例题：<a href="!https://www.acwing.com/problem/content/347/">345.牛站</a></p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^3*logm)</li>
</ul>
<h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li>Floyd思想：<ul>
<li>状态表示：d[K][i][j]为从i到j的经过前K条边的路径的最小值(与Floyd的d[n][i][j]经过前n个点的表示方法略有不同)</li>
<li>状态计算：d[K][i][j] = d[a][i][k] + d[b][k][j]，其中k为经过前a条边后的点，</li>
<li>更新一次可以增加两条边，更新两次增加三条边，如此我们仅需更新m-1次即可得到d[m][S][E]，时间复杂度为：O(n^3*m) n为200，m为1e6必定TLE</li>
<li>可以用倍增思想来将时间复杂度化为logm</li>
</ul>
</li>
<li>倍增思想(快速幂思想)<ul>
<li>最终路径类似于：S-&gt;x1-&gt;x2-&gt;x3-&gt;……-&gt;……-&gt;xm-1-&gt;E, 中间经过了m-1个点，m条边</li>
<li>我们可发现上述的路径先计算与后计算不会相互影响，即可以先计算中间的或先计算后面的，具有结合律，如此可借助倍增思想，仅需logm次即可找到合法路径</li>
<li>时间复杂度：O(n^3*logm)</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>哈希所有用过的点，包括起点和终点</li>
<li>倍增算法</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K, S, E;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> res[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> temp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k] + b[k][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(c, temp, <span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倍增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一条边都不走，i-&gt;i必须为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res[i][i] = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (K &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, g);</span><br><span class="line">        <span class="built_in">mul</span>(g, g, g);</span><br><span class="line">        K &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; m &gt;&gt; S &gt;&gt; E;</span><br><span class="line">    </span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ids;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(S)) ids[S] = ++ n;</span><br><span class="line">    <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(E)) ids[E] = ++ n;</span><br><span class="line">    S = ids[S], E = ids[E];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化自环为0，即经过一条边走到自身的权值为0，多此一举</span></span><br><span class="line">    <span class="comment">// 因为通过一条边的权值可能大于0，如果初始化为0，则之后的边无法在g中表现出来</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= N; i ++ )</span></span><br><span class="line">    <span class="comment">//     g[i][i] = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(a)) ids[a] = ++ n;</span><br><span class="line">        <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(b)) ids[b] = ++ n;</span><br><span class="line">        a = ids[a], b = ids[b];</span><br><span class="line">        </span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qmi</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res[S][E] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>Floyd思想和倍增思想</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal算法</title>
    <url>/posts/8708cb74/</url>
    <content><![CDATA[<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(mlogm)</li>
</ul>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>求朴素最小生成树</li>
<li>求最小生成森林，(求最小生成树的前一半)</li>
<li>已知一些边，求最小生成树(求最小生成树的后一半)</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>将所有边按照权重从小到大排序</li>
<li>枚举每条边的顶点a, b, 权重c，若a, b不在一个集合，则合并a, b集合, 反之则跳过，判断下一条边</li>
</ul>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>证明思路与prim算法类似。<ul>
<li>如何证明这条边一定可以被选？</li>
<li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会形成一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差。</li>
</ul>
</li>
<li>证明结论：若该边的两点所在的集合不同，则该边必定在最小生成树中</li>
<li>证明结论如下：<ul>
<li>反证法：假设没有选择该边x1，则必定选择了之后的边x2使得两集合合并，使之形成最小生成树</li>
<li>证明：把边x1加到用x2形成的最小生成树中，则会在形成一个环，且该边一定包含x1,x2，此时若把x2去除，则形成的也为一个生成树，且因为x1小于x2，新生成的生成树比原来的权值和还小，则可证x1比x2更合适，所以得证，若上述证明结论的情况发生，则必定成立！</li>
</ul>
</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kruskal 算法同样可以求最小生成森林（不全部连通的最小生成树）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b) p[a] = b;</span><br><span class="line">        <span class="keyword">else</span> res += edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>kruskal算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>kruskal算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim算法</title>
    <url>/posts/a72d76aa/</url>
    <content><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^2 + m)</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>邻接矩阵存边的权值</li>
<li>距离初始化为正无穷</li>
<li>每次选择当前集合终和外界所连边的权值最小的点</li>
<li>将该边所连的点扩展，并用刚扩展的点更新其他点到当前集合的权值</li>
</ul>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>证明思路与kruskal算法类似。<ul>
<li>如何证明这条边一定可以被选？</li>
<li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会形成一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差。</li>
</ul>
</li>
<li>证明结论：当前与外界直接相连的权值最小的一条边，这条边一定可以出现在最优解中。</li>
<li>证明过程如下：<ul>
<li>反证法：假设选择最小生成树的某一个状态集合x扩展某一个边x1(最小)时没有选择该边，选择了另一个边x2(非最小)，从而形成了一个生成树。</li>
<li>证明：已知集合x可扩展多个边x1, x2……x’等(权值升序排列)，选择了x2边扩展。若将x1边加入扩展了x2边而最终形成的生成树中，则必定会形成一个环，且该环上一定包含x’这条边，因为x1为扩展出来的权值最小的边，x’等其他边时扩展出来的非权值第一小边，则将x’去掉，x1加上，形成的还是一个生成树，且该生成树的总权值小于原来的生成树。如此，得证。</li>
</ul>
</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>prim算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>prim算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA求负环</title>
    <url>/posts/318426d0/</url>
    <content><![CDATA[<h1 id="SPFA求负环"><a href="#SPFA求负环" class="headerlink" title="SPFA求负环"></a>SPFA求负环</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>O(km)，最坏O(nm)</li>
</ul>
<h2 id="两种方法："><a href="#两种方法：" class="headerlink" title="两种方法："></a>两种方法：</h2><ul>
<li>法一：统计每个点入队的次数，如果某个点入队n次，则说明存在负环</li>
<li>法二：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数&gt;=n，则说明存在负环</li>
<li>都是基于抽屉原理（鸽巢原理）</li>
<li>一般用法二，时间复杂度更低</li>
</ul>
<h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><ul>
<li>为什么等价于将所有点入队？<br>解释：建立虚拟源点，并将虚拟源点和其他所有点连一条边</li>
<li>为什么求负环时不需要将其他点初始化为正无穷？<br>如果存在负环，则dist最终为-INF，所以dist无论时INF还是0无所谓，会绕负环无穷次，对于无穷而言具体的值就无所谓了。</li>
</ul>
<h2 id="关于TLE的优化"><a href="#关于TLE的优化" class="headerlink" title="关于TLE的优化"></a>关于TLE的优化</h2><ul>
<li>做题前要思考如何建图方便，因为spfa时间复杂度很危险，如何降低点和边的数量使关键</li>
<li>若时间复杂度接近O(nm)则可以默认其已经含有负环，具体可根据经验，(比如，当所有的入队次数超过2n时，我们就认为图中有很大可能时存在负环的)，缺点是不太稳定</li>
<li>将队列转化为栈，面对找负环的问题一般效率比较好，比上面的trick较稳定一些</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><p>队列 + trick(小花招): 200ms +</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m1, m2;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true有负环，false无负环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列改栈: 400ms+</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">700</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[tt -- ];</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[ ++ tt] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> str[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1010</span>;</span><br><span class="line">            <span class="keyword">while</span>(r - l &gt; <span class="number">1e-4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>SPFA求负环</category>
      </categories>
      <tags>
        <tag>spfa</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>Test01</title>
    <url>/posts/d3e5ea48/</url>
    <content><![CDATA[<p><a href="http://www.bilibili.com/">跳转到B站</a></p>
<h1 id="测试的文章"><a href="#测试的文章" class="headerlink" title="测试的文章"></a>测试的文章</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<p><strong>BP算法</strong></p>
<p>训练集    $\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}$</p>
<p>设    $\Delta_{i j}^{(l)}=0(\text { for all } l, i, j)$</p>
<p>$\begin{array}{l}{\text {For } i=1 \text { to } m}\end{array}$</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\text { Set } a^{(1)}=x^{(i)}} \\ {\text { Perform forward propagation to compute } a^{(l)} \text { for } l=2,3, \ldots, L} \\ {\text { Using } y^{(i)}, \text { compute } \delta^{(L)}=a^{(L)}-y^{(i)}} \\ {\text { Compute } \delta^{(L-1)}, \delta^{(l+1)}, \ldots, \delta^{(2)}} \\ {\Delta_{i j}^{(l)} :=\Delta_{i j}^{(l)}+a_{j}^{(l)} \delta_{i}^{(l+1)}}\end{array}</script><p>$\begin{array}{l}{D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}+\lambda \Theta_{i j}^{(l)}} &amp; {\text { if } j \neq 0} \\ {D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}} &amp; {\text { if } j=0}\end{array}$</p>
<p>其中    $\frac{\partial}{\partial \Theta_{i j}^{(l)}} J(\Theta)=D_{i j}^{(l)}$</p>
<hr>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>二分</tag>
        <tag>双指针</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/posts/973bc934/</url>
    <content><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><h3 id="时间复杂度：O-n-m"><a href="#时间复杂度：O-n-m" class="headerlink" title="时间复杂度：O(n + m)"></a>时间复杂度：O(n + m)</h3><p><strong>算法实现：</strong>邻接表存储，dfs一遍，没染色，则染上色</p>
<h3 id="结论1："><a href="#结论1：" class="headerlink" title="结论1："></a>结论1：</h3><blockquote>
<p>一个图是二分图 == 图中不存在奇数环 == 染色法不存在矛盾</p>
</blockquote>
<p>p -&gt; q : p 是 q 的充分条件，q 是 p 的必要条件</p>
<p>假设 如上三个条件为 a == b == c</p>
<h3 id="证明1："><a href="#证明1：" class="headerlink" title="证明1："></a>证明1：</h3><ul>
<li>b 直接推 a 不太容易，所以 b -&gt; c - &gt; a </li>
<li>b -&gt; c ：<ul>
<li>反证法：假设图中不存在奇数环 但 染色法出现了矛盾。</li>
<li>假设第一个矛盾为两个白色相连，则在该连通块(环)中其他的点一定不存在矛盾，其染色一定为 白-黑-白-黑-……-白，首尾都为白，则符合我们的假设。如此一来，此连通块一定有奇数个点与已知反证法条件相矛盾，则原结论成立。</li>
</ul>
</li>
<li>c -&gt; b : <ul>
<li>反证法：如果染色的过程中不存在矛盾 但 图中存在奇数环</li>
<li>假设一个环的头为白色，有因为其是奇数环，则其尾一定也为白色，首尾都是白色，所以该图存在矛盾，原结论成立。</li>
</ul>
</li>
<li>(b, c) -&gt; a<ul>
<li>因为染色法不存在矛盾，则 白黑 相间连接，把白色黑色分别拿出，则构成二分图。</li>
</ul>
</li>
<li>a -&gt; (b, c)<ul>
<li>反证法：假设一个图是二分图，但图中存在奇数环</li>
<li>奇数环的任意一点出发，则与此点相连的点在另外一个集合中，依此类推，则最后会剩余两个相连的点，但却在同一个集合中，即、此图不是一个二分图，与反证法条件产生矛盾，则原结论成立。</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/259/">257. 关押罪犯</a></p>
<p><strong>思路：</strong>二分 + 染色法</p>
<ul>
<li>二分的两段性：假设 x 为最优解，即、x -&gt; 右的边可以构成二分图，若 x 向右移动，仍然可以构成二分图(二分图去掉一些边仍然是二分图，减去一些限制，更自由了)，左边一定不成立，应为 x 为当前的最优解，所以若 check(mid) == true，则当前的图可以构成二分图，向左移动看是否可以构成二分图，若恰好可以构成，则为最优解。</li>
</ul>
<h3 id="染色法-代码模板："><a href="#染色法-代码模板：" class="headerlink" title="染色法-代码模板："></a>染色法-代码模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 没染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匈牙利算法-增广路算法"><a href="#匈牙利算法-增广路算法" class="headerlink" title="匈牙利算法(增广路算法)"></a>匈牙利算法(增广路算法)</h2><h3 id="时间复杂度：O-n-m-1"><a href="#时间复杂度：O-n-m-1" class="headerlink" title="时间复杂度：O(n * m)"></a>时间复杂度：O(n * m)</h3><p><strong>作用：</strong>求二分图最大匹配数目</p>
<p><strong>思路：</strong>枚举一边，如果重复，看上一个能不能换</p>
<h3 id="基本概念-针对二分图所言"><a href="#基本概念-针对二分图所言" class="headerlink" title="基本概念(针对二分图所言)"></a>基本概念(针对二分图所言)</h3><ul>
<li>匹配：”任意两条边都没有公共端点”的边的集合，被称为图的一组匹配</li>
<li>最大匹配：包含边数最多的一组匹配，被称为二分图的最大匹配</li>
<li>匹配点：在匹配中的点</li>
<li>非匹配点：不在匹配中的点</li>
<li>增广路径：从非匹配点走，非匹配边，匹配边，非匹配边，匹配边，最终通过非匹配边走到了非匹配点，则该路径称为增广路径，增广路径可以使匹配的边数 + 1，匹配的点数 + 2</li>
</ul>
<h3 id="结论1：-1"><a href="#结论1：-1" class="headerlink" title="结论1："></a>结论1：</h3><blockquote>
<p>一个匹配是最大匹配 == 不存在增广路径</p>
</blockquote>
<h3 id="匈牙利算法-代码模板："><a href="#匈牙利算法-代码模板：" class="headerlink" title="匈牙利算法-代码模板："></a>匈牙利算法-代码模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;  <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;  <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集</span></span><br><span class="line">                             <span class="comment">// 合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];  <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图的覆盖与独立集"><a href="#二分图的覆盖与独立集" class="headerlink" title="二分图的覆盖与独立集"></a>二分图的覆盖与独立集</h2><p>包含的概念：最小点覆盖，最大独立集，最小路径点覆盖(特殊情况：最小路径重复点覆盖)</p>
<blockquote>
<p>结论：<strong>在二分图中</strong> 最大匹配数 == 最小点覆盖 == 总点数 - 最大独立集 == 总点数 - 最小路径点覆盖</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>最小点覆盖：给定一个图，求一个最小的点集 S ，使得图中任意一条边都至少一个端点属于 S。 </li>
<li>最大独立集：给定一个图，选出最多的点，使得选出的点之间没有边，等于补图的最大团。</li>
<li>最大团：给定一个图，选出最多的点，使得选出的点之间都有边，等于补图的最大独立集。</li>
<li>最小路径点覆盖(也称为最小路径覆盖): 在有向无环图(DAG)中，用最少的互不相交的路径(点和边都不重复)，将所有点覆盖住。</li>
</ul>
<h3 id="结论1-："><a href="#结论1-：" class="headerlink" title="结论1 ："></a>结论1 ：</h3><blockquote>
<p>在二分图中：最小点覆盖 == 最大匹配数</p>
</blockquote>
<h3 id="证明1：-1"><a href="#证明1：-1" class="headerlink" title="证明1："></a>证明1：</h3><ul>
<li>最小点覆盖 &gt;= 最大匹配数:<ul>
<li>一条边至少要选一个点，所以 最小点覆盖一定 &gt;= 最大匹配数</li>
</ul>
</li>
<li>最小点覆盖 == 最大匹配数：(证明<strong>等号</strong>可以成立) (构造)<ul>
<li>步骤如下：</li>
</ul>
<ol>
<li>求最大匹配</li>
<li>从左部每个非匹配点出发，做一遍增广，标记所有经过的点。则，<strong>左边所有未被标记的点，和右边所有被标记的点</strong> 即为 所求的匹配数。</li>
<li>可以发现以下的性质：<ol>
<li>左部所有非匹配点，一定被标记，</li>
<li>右部所有非匹配点一定未被标记(若右边的非匹配点被标记，此路径即为增广路径，非 - …… - 非，所以右部所有非匹配点一定未被标记)</li>
</ol>
</li>
<li>之后我们只需证明 <strong>所有边一定只有一个点被选</strong>即可。可以发现一共有四种边，左匹配 - 右匹配， 左非匹配 - 右匹配，左匹配 - 右非匹配，左非匹配 - 右非匹配</li>
<li>对于 <strong>左匹配 - 右匹配</strong> (匹配边) 而言，只有两种情况，<strong>同时被标记</strong> 和 <strong>同时不被标记</strong>，右边的点是随左边的点而变化。对于每个匹配而言，则左边所有未被标记的点，一定为匹配点，右边所有被标记的点，一定为匹配点。因此证明，对于每一条匹配边而言，如果左右同时被标记，则选择右边的点计数；如果左右两边同时不被标记，则选择左边的点计数，如此即可保证，对于每个匹配边，必定会选择其中一个点覆盖此边。</li>
<li>对于 <strong>左非匹配 - 右匹配</strong>，则右匹配点一定被标记，右匹配点一定被选，左非匹配点一定不被选。</li>
<li>对于 <strong>左匹配 - 右非匹配</strong>，则左匹配点一定未被标记，如此则右匹配点一定也未被标记，则我们会选择，左边未被标记的点，而右边的未被标记的点则一定不会被选。</li>
<li>对于 <strong>左非匹配 - 右非匹配</strong>，此情况一定不存在，因为此情况表示存在一条增广路径，原图做过最大匹配的算法了，则一定不存在增广路径。</li>
<li>如此我们即证明了，对于所有边一定有一个点且只有一个点被覆盖。</li>
</ol>
</li>
</ul>
<p><strong>例题1：</strong><a href="https://www.acwing.com/problem/content/378/">376. 机器任务</a></p>
<p><strong>思路：</strong>最小点覆盖 (匈牙利算法求最大匹配数即可)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; g[x][i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> t = match[i];</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span> || <span class="built_in">find</span>(t))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span>(k -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t, a, b;</span><br><span class="line">            cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(!a || !b) <span class="keyword">continue</span>;</span><br><span class="line">            g[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论2："><a href="#结论2：" class="headerlink" title="结论2："></a>结论2：</h3><blockquote>
<p>在二分图中，最大独立集 ==  总点数 - 最大匹配数</p>
</blockquote>
<h3 id="证明2："><a href="#证明2：" class="headerlink" title="证明2："></a>证明2：</h3><ul>
<li>最大独立集 == 去掉最少的点，将所有边都破坏掉，剩余的点的数量 == 总点数 - 最小点覆盖 == 总点数 - 最大匹配数</li>
</ul>
<p><strong>例题2：</strong> <a href="https://www.acwing.com/problem/content/380/">378. 骑士放置</a></p>
<p><strong>思路：</strong>最大独立集</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">1</span> || a &gt; n || b &lt; <span class="number">1</span> || b &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b] || g[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        PII t = match[a][b];</span><br><span class="line">        <span class="keyword">if</span>(!t.x || <span class="built_in">find</span>(t.x, t.y))</span><br><span class="line">        &#123;</span><br><span class="line">            match[a][b] = &#123;x, y&#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) % <span class="number">2</span> || g[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i, j)) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; n * m - k - res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论3："><a href="#结论3：" class="headerlink" title="结论3："></a>结论3：</h3><blockquote>
<p>在二分图中，最大匹配数 == 总点数 - 最小路径点覆盖</p>
</blockquote>
<h3 id="证明3："><a href="#证明3：" class="headerlink" title="证明3："></a>证明3：</h3><ul>
<li>结论转化为：最小路径点覆盖 = 总点数 - 最大匹配数</li>
<li>最小路径点覆盖如何实现：<ul>
<li>用拆点实现：一个点拆为两个点 入点i 和 出点i ，做完最小路径点覆盖，得到的图是二分图， 入点和出点的集合一定在两侧。</li>
</ul>
</li>
<li>原图的路径 转化到 新图(拆完点的图)中为：新图中的边必然无公共点，原路径对应新图的一个匹配</li>
<li>原图的路径终点 在新图中没有出边，等价于 左部的非匹配点，则原证明可以转化为：让左侧的非匹配点最少(n-m)，等价于 让左侧的匹配点最多(m) 等价于 找最大匹配(m)</li>
</ul>
<h3 id="结论4："><a href="#结论4：" class="headerlink" title="结论4："></a>结论4：</h3><blockquote>
<p>在二分图中，最大匹配数 == 总点数 - 最小路径<strong>重复</strong>点覆盖(是最小路径点覆盖的扩展)</p>
</blockquote>
<h3 id="证明4："><a href="#证明4：" class="headerlink" title="证明4："></a>证明4：</h3><ul>
<li>先求传递闭包，则 原图的最小路径重复点覆盖 可以转化为 新图的最小路径点覆盖(新结论)</li>
<li>证明新结论：</li>
<li>左 -&gt; 右：如果原图的路径有交集，则直接跳过交集的部分，一直跳过，直到无交集位置，如此即为新图上的最小路径点覆盖</li>
<li>左 &lt;- 右：将新图的间接边转化为原图的直接边，则可以成立。</li>
</ul>
<p><strong>例题：</strong> <a href="https://www.acwing.com/problem/content/381/">379. 捉迷藏</a></p>
<p><strong>思路：</strong> 总点数 - 最小重复路径点覆盖 == 最大匹配数</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; g[x][i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> t = match[i];</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span> || <span class="built_in">find</span>(t))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                g[i][j] |= g[i][k] &amp; g[k][j];</span><br><span class="line">                </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; n - res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>染色法</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>传递闭包</title>
    <url>/posts/39d70f23/</url>
    <content><![CDATA[<h1 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^3)</li>
</ul>
<h2 id="算法解释：若-a-gt-b-b-gt-c-则-a-gt-c，将所有的间接到的点化为直接到，如此称为传递闭包"><a href="#算法解释：若-a-gt-b-b-gt-c-则-a-gt-c，将所有的间接到的点化为直接到，如此称为传递闭包" class="headerlink" title="算法解释：若 a-&gt;b, b-&gt;c 则 a-&gt;c，将所有的间接到的点化为直接到，如此称为传递闭包"></a>算法解释：若 a-&gt;b, b-&gt;c 则 a-&gt;c，将所有的间接到的点化为直接到，如此称为传递闭包</h2><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>直接Floyd算法</li>
<li>更新距离的函数变一下即可</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] |= d[i][k] &amp; d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>传递闭包</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>传递闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>双端队列广搜</title>
    <url>/posts/88e344b2/</url>
    <content><![CDATA[<h1 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h1><h2 id="时间复杂度；"><a href="#时间复杂度；" class="headerlink" title="时间复杂度；"></a>时间复杂度；</h2><ul>
<li>每次从队列中取出队头为 $O(1)$</li>
<li>整体时间复杂度为线性的，即 $O(n + m)$</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>边权仅为0或1的图中</li>
</ul>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><p>(整体思路类似堆优化 $dijkstra$ 算法)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次取出队头，时间复杂度O(1)</span></span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!v) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>类似堆优化 $dijkstra$ 算法，因为边权只有0和1，可以将0插入队头，1插入队尾，可以保证单调性的同时，将从优先队列中取出最小值的 $O(logm)$ 的步骤，优化为只取出队头的 $O(1)$ 操作，从而将时间复杂度降低为线性</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
        <category>双端队列广搜</category>
      </categories>
      <tags>
        <tag>双端队列广搜</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/posts/417dcd30/</url>
    <content><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>用最短路算法(spfa)实现</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>求不等式组的可行解</li>
<li>如何求最大值和最小值</li>
</ol>
<h2 id="知识点如下；"><a href="#知识点如下；" class="headerlink" title="知识点如下；"></a>知识点如下；</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/09/03/142813_94cfc2962b-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F.png" alt="差分约束"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/03/142813_dd59e5382b-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F_2.png" alt="差分约束"></p>
<ul>
<li>差分约束如何建图：</li>
<li>首先明确，求最短路用 <code>i &lt;= j + x</code> 来更新距离，含义为 j-&gt;i 边权为x，文字表示为i可用j来更新，求最长路用 <code>i &gt;= j + x</code> 来更新距离，同理。</li>
<li>求最小值( &gt;= x的最小值)，所有的不等式化为<code>i &gt;= j + x</code>，添边:add(j, i, x)，求x0到每个点xi的最长路。</li>
<li>求最大值( &lt;= x的最大值)，所有的不等式化为<code>i &lt;= j + x</code>，添边为add(j, i, x)，求x0到每个点xi的最短路，</li>
</ul>
<p><strong>注意：</strong>若涉及区间和的问题，考虑前缀和，转化为两点之间的关系</p>
<h2 id="例题：1169-糖果"><a href="#例题：1169-糖果" class="headerlink" title="例题：1169. 糖果"></a>例题：<a href="https://www.acwing.com/problem/content/1171/">1169. 糖果</a></h2><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 1, A &gt;= B &amp;&amp; B &gt;= A</span></span><br><span class="line"><span class="comment">x = 2, B &gt;= A + 1</span></span><br><span class="line"><span class="comment">x = 3, A &gt;= B</span></span><br><span class="line"><span class="comment">x = 4, A &gt;= B + 1</span></span><br><span class="line"><span class="comment">x = 5, B &gt;= A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[-- tt];</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>), <span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">add</span>(a, b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) <span class="built_in">add</span>(b, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>()) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            res += dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/fb40efc5/</url>
    <content><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><ul>
<li>在一个有向图中，对所有节点排序后，对于每一条边都是前面指向后面，没有由后面指向前面的边，则称新的序列为有向图的拓扑排序。若有向图存在环，必然没有拓扑排序；若有向图无环，则必然存在一个拓扑排序。</li>
<li>如果一个图是可以拓扑排序的，则称此图为拓扑图 == 有向无环图(DAG)</li>
</ul>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><ul>
<li>将所有入读为0的点入队<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (q 非空)</span><br><span class="line">&#123;</span><br><span class="line">  t &lt;- q的头节点</span><br><span class="line">  <span class="keyword">for</span> t 的所有出边 t -&gt; j</span><br><span class="line">  &#123;</span><br><span class="line">      -- d[j];</span><br><span class="line">      <span class="keyword">if</span> (d[j] == <span class="number">0</span>) q &lt;- j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="算法模板如下："><a href="#算法模板如下：" class="headerlink" title="算法模板如下："></a>算法模板如下：</h2><p>如果求字典序最小的拓扑排序，将 队列换成优先队列即可。</p>
<p>当前队列的元素为 度数为0 的点，当前序列中的点一定为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>( -- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路求方案数</title>
    <url>/posts/1e2a4971/</url>
    <content><![CDATA[<h1 id="最短路求方案数"><a href="#最短路求方案数" class="headerlink" title="最短路求方案数"></a>最短路求方案数</h1><h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><ul>
<li>首先引入拓扑序的概念：计算当前状态时，当前状态所依赖的状态都已经计算出来了</li>
<li>类似DP，先求出全局最小值，再分别求出每个子集中等于全局最小值的元素数量，和最短路的唯一区别是，DP是在拓扑图中做最短路，但普通的最短路中可能存在环</li>
<li>若将最短路的模型转化为拓扑图，则可以用类似DP的方式处理求方案数的问题</li>
<li>其次引入最短路树（最短路拓扑图）<ul>
<li>概念：记录每个点是由哪个点更新来的，即若 <code>dist[j] = dist[t] + w[i] (t -&gt; j)</code>，j 可由 t 更新而来。</li>
<li>如果没有任何限制，则可能存在权值为0的环，可以在此环上转无限次，则最短路径的方案数为 INF，相当于无解了，求不出确切的树。</li>
<li>所以，如果想要求最短路的方案数，则图中不能存在权值为0的环，依照上述方案记录路径，即可形成拓扑图，简单地说，将可以求最短路时可以被利用的边保存（可更新最短路径上的点的边保存），其余边去掉。</li>
</ul>
</li>
</ul>
<h2 id="分析算法："><a href="#分析算法：" class="headerlink" title="分析算法："></a>分析算法：</h2><p>求最短路的算法系列：</p>
<p>热知识：判断是否满足拓扑序，此点不能更新之前已更新的点，反之则形成环，非拓扑序</p>
<ul>
<li>BFS系列（bfs）<ul>
<li>一层一层扩展，保证每个点只入队一次，且只出队一次，满足拓扑序</li>
</ul>
</li>
<li>Dijkstra系列（朴素dijkstra，堆优化dijkstra，双端队列广搜）<ul>
<li>每个点只作为最小值出队一次，之前出现的点的距离一定小于等于该点的距离，所以此点一定不会更新之前的点，满足拓扑序</li>
</ul>
</li>
<li>Bellman-ford系列（Bellman-ford，spfa）<ul>
<li>按照边更新，一个点出队都无法确定其为最小值，每个点可能入队多次，本身不具备拓扑序，若使用则需先用spfa算法预处理出来最短路径，建立最短路径树，然后在最短路径树上跑bfs等算法。</li>
</ul>
</li>
</ul>
<p>总结：bfs系列和dijkstra系列算法可以直接做，spfa比较麻烦需要预处理。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>, cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[ ++ tt ] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + <span class="number">1</span>)</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>方案数</category>
      </categories>
      <tags>
        <tag>方案数</tag>
      </tags>
  </entry>
  <entry>
    <title>无向图的双连通分量(DCC)</title>
    <url>/posts/b8105b5b/</url>
    <content><![CDATA[<h1 id="无向图的双连通分量-DCC"><a href="#无向图的双连通分量-DCC" class="headerlink" title="无向图的双连通分量(DCC)"></a>无向图的双连通分量(DCC)</h1><blockquote>
<p>可分为 边双连通分量(e-DCC) 与 点双连通分量(v-DCC)</p>
</blockquote>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>点双连通分量不一定是边双连通分量，边双连通分量也不一定是点双连通分量</li>
<li>割点与桥<strong>没有</strong>什么本质的关系</li>
<li>两个割点之间的边不一定是桥</li>
<li>一个桥的两个端点不一定是割点</li>
</ul>
<h2 id="边双连通分量-e-DCC"><a href="#边双连通分量-e-DCC" class="headerlink" title="边双连通分量(e-DCC)"></a>边双连通分量(e-DCC)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>桥：一条无向边，若删除此边，整个图变得不连通，则称这条边为“桥”。</li>
<li>边双连通分量：极大的不包含“桥”的连通块，则称为“边的双连通分量”</li>
<li>性质：<ol>
<li>无论删除哪一条边，整个图一定还是连通的</li>
<li>任意两点之间一定包含两条不相交的路径(边不相交)。</li>
</ol>
</li>
</ul>
<h3 id="Tarjan算法求边的双连通分量"><a href="#Tarjan算法求边的双连通分量" class="headerlink" title="Tarjan算法求边的双连通分量"></a>Tarjan算法求边的双连通分量</h3><ul>
<li>时间戳(timestamp)，dfn[N], low[N], 和有向图的强连通分量作用相同</li>
<li>如何找到桥？<ul>
<li>若子节点可以走到父节点或祖先节点，则从父节点到子节点的边不是桥，等价于，若边 x-y 为桥，则 dfn[x] &lt; low[y]</li>
</ul>
</li>
<li>如何找到边双连通分量？<ul>
<li>方法一：将所有桥删去</li>
<li>方法二：类似于有向图的强连通分量的Tarjan算法，用栈(stk数组)维护，刚开始搜索加到栈里，若dfs[i] == low[i]的话(即、i的父节点到i这条边为桥)，则i当前所在的子树中的节点即为当前边的双连通分量中的点。</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/397/">395. 冗余路径</a></p>
<p><strong>题意：</strong></p>
<p>给定一个无向连通图，<br>问：最少加几条边，使得任何两点之间都至少有两条边；等价于，最少加几条边，可以将其变成边双连通分量。</p>
<p><strong>结论1：</strong></p>
<blockquote>
<p>任何两点之间都至少有两条边；等价于，此图为边双连通分量</p>
</blockquote>
<p><strong>证明1：</strong></p>
<ul>
<li>充分性：左 -&gt; 右<ul>
<li>如果 任何两点之间都至少有两条边 则 此图是边双连通分量</li>
<li>反证法：假设任何两点之间都包含两条互不相交的路径，如果其不是边的双连通分量，则意味着这个图中，至少存在一个桥。</li>
<li>在桥两侧的连通块中任意找两个点x, y，则x到y的所有路径都经过桥这条边，所以x, y两点之间不存在两条互不相交的路径，与条件中的 任何两点直接按都包含两条互不相交的路径相矛盾，则假设不成立，原命题成立。</li>
</ul>
</li>
<li>必要性：左 &lt;- 右<ul>
<li>如果 此图是边双连通分量 则 任何两点之间都至少有两条边</li>
<li>左可推：此图不含桥，假设两点 x, y 则 x, y 的最短路径为连接 x, y 的一条边，对于该边中的每一段边，都可以直到这个边不是桥，则两个连通块之间必定有两外一条边，，基本思路为如此，具体证明y也不太清楚hh。</li>
</ul>
</li>
</ul>
<p><strong>结论2：</strong></p>
<blockquote>
<p>如果度数为 1 的点的个数为 cnt 个，则需要新加 (cnt + 1) / 2 条边，可以使得此图变为边的双连通分量。</p>
</blockquote>
<p><strong>证明2：</strong></p>
<ul>
<li>证明 ans &gt;= (cnt + 1) / 2 : 若此图边为边的双连通分量，等价于所有点的度数 &gt;= 2 , 即、所有度数为 1 的点都至少需要加一条边，最优先的连边策略为两个度数为 1 的点连一条边，消除两个度数为 1 的点，如果剩余一个点，此点随便连一个点即可，如此新加的边的个数的最优策略为 cnt / 2上取整，等价于 (cnt + 1) / 2 下取整，即所求新加的边 ans &gt;= (cnt + 1) / 2 (最优解)。</li>
<li>证明 ans == (cnt + 1) / 2 : 可知如果可以取到 (cnt + 1) / 2，则 我们所求的 ans == (cnt + 1) / 2; <ul>
<li>边界：当 只有两个点时，加一条边即可，(2 + 1) / 2 == 1 成立</li>
<li>至少有三个点：以一个度数至少为 2 的点为根节点，则所有度数为 1 的点都为叶子节点，两个叶子节点相连，剩余一个随便连，则新加的边的数量为 (cnt + 1) / 2，也成立。</li>
</ul>
</li>
<li>大致证明为以上的叙述，，具体证明太麻烦，就此告一段落，记住结论即可。</li>
</ul>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">int</span> dcc_id[N], dcc_cnt;</span><br><span class="line"><span class="type">bool</span> is_bridge[M];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from 为u是从哪条边来的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j, i); <span class="comment">// i 为边的编号</span></span><br><span class="line">            <span class="comment">// 关于此处为什么判断边?</span></span><br><span class="line">            <span class="comment">// 首先不可武断的判断是否为父节点父节点，我们要找的是边的双连通分量，两点之间可以有多条</span></span><br><span class="line">            <span class="comment">// 边，可能从 x - y 之间有 a, b 两条边，从 a 边下来，又从 b 边上去，这是可行的，若直接</span></span><br><span class="line">            <span class="comment">// 判断点，则 b 边是不可走，错误。</span></span><br><span class="line"></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] &lt; low[j])</span><br><span class="line">                is_bridge[i] = is_bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != (from ^ <span class="number">1</span>)) <span class="comment">// 边成对出现</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ dcc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];</span><br><span class="line">            dcc_id[y] = dcc_cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接判断所有边是不是桥，若是，则相邻的两条边的 e[i] 所在的 dcc_id都会加上 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(is_bridge[i])</span><br><span class="line">            d[dcc_id[e[i]]] ++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">1</span>) </span><br><span class="line">            cnt ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (cnt + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点双连通分量-v-DCC"><a href="#点双连通分量-v-DCC" class="headerlink" title="点双连通分量(v-DCC)"></a>点双连通分量(v-DCC)</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>割点：一个点，若删除此点，整个图变得不连通，则称这个点为“割点”</li>
<li>点双连通分量：极大的不包含“割点”的连通块，则称为“点的双连通分量”。</li>
<li>性质：<ol>
<li>每一个割点都会至少属于两个点双连通分量。 </li>
</ol>
</li>
</ul>
<h3 id="Tarjan算法求点的双连通分量"><a href="#Tarjan算法求点的双连通分量" class="headerlink" title="Tarjan算法求点的双连通分量"></a>Tarjan算法求点的双连通分量</h3><ul>
<li>时间戳(timestamp)，dfn[N], low[N], 和有向图的强连通分量作用相同</li>
<li>如何找到割点？若，对于 x - y，在 low[y] &gt;= dfn[x] (最多只能走到父节点) 的情况下：<ul>
<li>如果 x 不是根节点，那么 x 必定是一个割点</li>
<li>如果 x 是根节点，至少有两个子节点，那么 x 必定是一个割点</li>
</ul>
</li>
<li>如何求点的双连通分量？<ul>
<li>stack实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特判孤立点</span></span><br><span class="line"><span class="keyword">if</span> (u == 孤立点)</span><br><span class="line">&#123;</span><br><span class="line">  cnt ++ ;</span><br><span class="line">  此点单独为一个点的双连通分量；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dfn[x] &lt;= low[y])</span><br><span class="line">&#123;</span><br><span class="line">  cnt ++ ;</span><br><span class="line">  <span class="keyword">if</span> (x != 根节点 || cnt &gt; <span class="number">1</span>) x 是割点；</span><br><span class="line">  将栈中元素弹出，直至弹出 y 为止。</span><br><span class="line">  且 x 也属于此点的双连通分量。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>证明为什么将 x 加入 y 的双连通分量中：<ul>
<li>若 dfn[x] &lt;= low[y] 可以取到 = ，则 x 在此双连通分量是无可厚非的(必然的，正确的)</li>
<li>若 dfn[x] &lt; low[y] ，则 缩点后 x - y 只有一条边相连，两点一边本身就是一个点双连通分量，所以将 x 加入此双连通分量也是正确的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/1185/">1183. 电力</a></p>
<p><strong>题意：</strong>删除一个点，可以形成的最多的连通块的个数为多少？</p>
<p><strong>思路：</strong>求割点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> root, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(low[u] &gt;= dfn[u]) cnt ++; <span class="comment">// 无法上去, 删去则多一个连通块</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(u != root) cnt ++; <span class="comment">// 不是根节点，加上u的父节点的连通块( + 1 )</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">        idx = timestamp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (root = <span class="number">0</span>; root &lt; n; root ++ )</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cnt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/398/">396. 矿场搭建</a></p>
<p><strong>题意；</strong>给定一个无向图，问最少在几个点上设置出口，可以使得不管其他哪个点坍塌，其余所有点都可以与某个出口相连；</p>
<p><strong>结论1：</strong>：</p>
<ul>
<li>出口数量 &gt;= 2</li>
<li>分别看每个连通块：<ul>
<li>(v-DCC 度数为0) 若 图中无割点(无论删除哪个点，剩余部分一定为连通的)：若 cnt 为图中点的个数， ans == C(2, cnt) == cnt * (cnt - 1) / 2</li>
<li>若 图中有割点：则需要缩点！<ul>
<li>每个割点单独作为一个点</li>
<li>从每个 v-DCC 向其所包含的每个割点连一条边</li>
</ul>
</li>
<li>v-DCC 度数为 1 ：需要在该分量内部(非割点)放一个出口</li>
<li>v-DCC 度数 &gt; 1 ：无需设置出口</li>
</ul>
</li>
</ul>
<p><strong>证明1：</strong></p>
<ul>
<li>缩点过，如果割点 坍塌，已知度数为 1 的点是叶子节点，则每一颗子树至少能被自己的叶子节点所救</li>
<li>如果度数为 1 的 v-DCC 中的某个点坍塌，可以通过割点走向另一个子树的叶子节点，从而逃脱</li>
<li>如果度数为 2 的 v-DCC 中的某个点坍塌，可以通过走到任意的一个割点从而走到子树的叶子节点，从而逃脱</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">int</span> dcc_cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判孤立点，也是点的双连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(u == root &amp;&amp; h[u] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc_cnt ++;</span><br><span class="line">        dcc[dcc_cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] &lt;= low[j])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++; <span class="comment">// 计算子树</span></span><br><span class="line">                <span class="keyword">if</span>(u != root || cnt &gt; <span class="number">1</span>) cut[u] = <span class="literal">true</span>;</span><br><span class="line">                ++ dcc_cnt;</span><br><span class="line">                <span class="type">int</span> y;</span><br><span class="line">                <span class="keyword">do</span> &#123;  </span><br><span class="line">                    y = stk[top -- ];</span><br><span class="line">                    dcc[dcc_cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">                &#125; <span class="keyword">while</span>(y != j); <span class="comment">// 加到 j 即可，不可加到 u ，可能有其他子树</span></span><br><span class="line">                dcc[dcc_cnt].<span class="built_in">push_back</span>(u); <span class="comment">// 最后补加一个割点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ ) dcc[i].<span class="built_in">clear</span>();</span><br><span class="line">        idx = n = timestamp = top = dcc_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">        <span class="built_in">memset</span>(cut, <span class="number">0</span>, <span class="keyword">sizeof</span> cut);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            n = <span class="built_in">max</span>(n, a), n = <span class="built_in">max</span>(n, b);</span><br><span class="line">            <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (root = <span class="number">1</span>; root &lt;= n; root ++ )</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        ULL num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dcc[i].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                <span class="keyword">if</span>(cut[dcc[i][j]])</span><br><span class="line">                    cnt ++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dcc[i].<span class="built_in">size</span>() &gt; <span class="number">1</span>) res += <span class="number">2</span>, num *= dcc[i].<span class="built_in">size</span>() * (dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>) res ++, num *= dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %llu\n&quot;</span>, ++ T, res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先(LCA问题)</title>
    <url>/posts/eaed4358/</url>
    <content><![CDATA[<h1 id="最近公共祖先-LCA问题"><a href="#最近公共祖先-LCA问题" class="headerlink" title="最近公共祖先(LCA问题)"></a>最近公共祖先(LCA问题)</h1><p>板子题：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/description/1174/">1172.祖孙询问</a></p>
<p>次小生成树应用：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/1173/">1171. 距离</a></p>
<p>树上差分应用：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/description/354/">352. 闇の連鎖</a></p>
<p>三种方法如下：第二和第三种更实用一些</p>
<h2 id="法一：向上标记法"><a href="#法一：向上标记法" class="headerlink" title="法一：向上标记法"></a>法一：向上标记法</h2><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>每次查询：最坏情况 O(n)</li>
</ul>
<h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><ul>
<li>x 向上走到根节点，并标记所有经过的节点</li>
<li>y 向上走到根节点，当第一次遇到已经标记的节点时，就找到了 LCA(x, y)。</li>
</ul>
<h2 id="法二：树上倍增法"><a href="#法二：树上倍增法" class="headerlink" title="法二：树上倍增法"></a>法二：树上倍增法</h2><h3 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>预处理：O(nlogn)</li>
<li>每次查询：O(logn)</li>
</ul>
<h3 id="算法实现：-1"><a href="#算法实现：-1" class="headerlink" title="算法实现："></a>算法实现：</h3><ul>
<li>预处理：<ul>
<li>预处理数组 fa[i][j] ：表示从 i 开始，向上走 2^j 所能走到的节点。0 &lt;= j &lt;= logn。<ul>
<li>如何预处理：dfs 或 bfs 都可以</li>
<li>若fa[i][j]的节点不存在，则令 <code>fa[i][j] == 0</code>。</li>
<li>当 <code>j == 0</code>时，fa[i][j] = i 的父节点</li>
<li>当 <code>j &gt; 0</code>时，fa[i][j] = fa[fa[i][j - 1]][j - 1]，即、先跳到2^(j-1) 步，再跳 2^(j-1) 步</li>
</ul>
</li>
<li>预处理数组 depth[i]：表示深度，或层数，规定根节点的深度为 1，子节点的深度为父节点深度 +1</li>
</ul>
</li>
<li>具体步骤如下：基于倍增的思想<ul>
<li>先将两个点跳到同一层，</li>
<li>让两个点同时向上跳，一直跳都他们的最近公共祖先的下一层(因为，当二者相等时无法判断是否为最近的公共祖先，所以跳到最近公共祖先的下一层)</li>
</ul>
</li>
<li>哨兵：depth[0] = 0。如果从 i 开始跳 2^j 步会跳过根节点，那么 fa[i][j] = 0，此时depth[fa[i][j]] = 0，哨兵生效，停止跳跃。<ul>
<li>具体作用如下：</li>
<li>保证 lca 两点跳到同一层时，越界的深度小于任何树中节点的深度，从而停止此次跳跃；</li>
<li>保证 lca 查找公共祖先时，越界的二者的父节点相同，都是0，从而停止此次跳跃。</li>
</ul>
</li>
</ul>
<h3 id="具体板子如下："><a href="#具体板子如下：" class="headerlink" title="具体板子如下："></a>具体板子如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>, K = <span class="built_in">log2</span>(N); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][K + <span class="number">1</span>]; <span class="comment">// 需要用 1~K 层, 开到 K + 1 保证不越界</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求每个点的深度 depth[i];</span></span><br><span class="line"><span class="comment">// f[i][j] 表示：从i点开始，向上走2^j步，(0 &lt;= j &lt;= logn);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哨兵：当f[i][j]为0时(即、i的向上走2^j步不存在时), depth[f[i][j]] = 0</span></span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点初始化</span></span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 向上走2^0步(1步)，为父节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递推处理fa[i][j], 有点st表的感觉</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 令 a 为较深的点</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 较深的点a 跳到和b的同一层</span></span><br><span class="line">    <span class="comment">// depth[0] = 0作用：</span></span><br><span class="line">    <span class="comment">// 保证 lca 两点跳到同一层时，越界的深度小于任何树中节点的深度，从而停止此次跳跃；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 若 a 和 b 为同一点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若父节点不同，则变为父节点，再次比较</span></span><br><span class="line">    <span class="comment">// depth[0] = 0作用：</span></span><br><span class="line">    <span class="comment">// 保证 lca 查找公共祖先时，越界的二者的父节点相同，都是0，从而停止此次跳跃。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三：Tarjan算法——离线求LCA"><a href="#法三：Tarjan算法——离线求LCA" class="headerlink" title="法三：Tarjan算法——离线求LCA"></a>法三：Tarjan算法——离线求LCA</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><blockquote>
<p>算法本质是，使用并查集对向上标记法的优化。离线算法，读入所有询问，统一计算，统一输出</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>O(n + m)</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li>在深度遍历时，将所有点分为三大类<ul>
<li>第一类点：已经遍历过，并且已经回溯过的点，标记为 2</li>
<li>第二类点：正在搜索的分支，标记为 1</li>
<li>第三类点：还未搜索到的点，标记为 0</li>
</ul>
</li>
<li>若求lca(x, y)，对于正在访问的节点 x ，即、x 的标记为 1。若 y 是已经遍历过且回溯过的节点，则 lca(x, y) 就是从 y 向上走到根，第一个遇见的标记为 1 的节点，其实就是向上标记法。</li>
<li>并查集优化：<ul>
<li>当一个节点获得标记 2 时，把它所在的集合合并到其父节点所在的集合中(合并时，其父节点一定为 1)</li>
<li>所有标记为 2 的节点，都有一个指针指向其祖宗节点。若 x 的标记为 1 ，y 的标记为 2，查询 y 的向上走的第一个标记为 1 的节点就是 y 的祖宗节点(一定标记为 1 )，此祖宗节点就是 lca(x, y)</li>
</ul>
</li>
</ul>
<h3 id="具体板子如下"><a href="#具体板子如下" class="headerlink" title="具体板子如下"></a>具体板子如下</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> res[M];</span><br><span class="line">vector&lt;PII&gt; query[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有点分为三类：</span></span><br><span class="line"><span class="comment">// 第一类. 已经遍历过且搜索过的点，标记为 2</span></span><br><span class="line"><span class="comment">// 第二类. 正在搜索的分支，标记为 1</span></span><br><span class="line"><span class="comment">// 第三类. 还未搜索的点，标记为 0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历与此点的询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son = it.x, id = it.y;</span><br><span class="line">        <span class="keyword">if</span>(st[son] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(son);</span><br><span class="line">            res[id] = dist[u] + dist[son] - dist[anc] * <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四：dfs序列-RMQ算法（例如，st表）"><a href="#法四：dfs序列-RMQ算法（例如，st表）" class="headerlink" title="法四：dfs序列 + RMQ算法（例如，st表）"></a>法四：dfs序列 + RMQ算法（例如，st表）</h2><p>麻烦，且很不常用，了解即可</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><ul>
<li>dfs 遍历得 dfs 序列</li>
<li>若求 lca(x, y) ，则在 dfs 序列中，找任意的 x 和 y 求之间的最小值，此最小值就是 lca(x, y)</li>
</ul>
<h2 id="LCA-应用"><a href="#LCA-应用" class="headerlink" title="LCA 应用"></a>LCA 应用</h2><h3 id="LCA-树上倍增算法的应用-——-次小生成树"><a href="#LCA-树上倍增算法的应用-——-次小生成树" class="headerlink" title="LCA 树上倍增算法的应用 —— 次小生成树"></a>LCA 树上倍增算法的应用 —— 次小生成树</h3><blockquote>
<p>将朴素求树上两点路径之间的最值，化为倍增求最值，从而将时间复杂度由 O(n^2) 优化为 O(nlogn)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d1[N][<span class="number">17</span>], d2[N][<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            edge[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = -INF, d2[j][k] = -INF;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span>(d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(a != b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k];</span><br><span class="line">                b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dist1 = -INF, dist2 = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist1) <span class="keyword">return</span> w - dist1;</span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist2) <span class="keyword">return</span> w - dist2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA-应用-——-树上差分"><a href="#LCA-应用-——-树上差分" class="headerlink" title="LCA 应用 —— 树上差分"></a>LCA 应用 —— 树上差分</h3><blockquote>
<p>点的权值表示边的权值，其中 d[i]：表示差分节点 i 的权值(即、i 通向父节点的边的权值)；如果在 x, y的路径上 + c，则只需令 d[x] += c, d[y] += c, d[p] -= 2c;(其中 p = lca(x, y))。最终答案为d[res]：res 的所有子树的权值和</p>
</blockquote>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, K = <span class="built_in">log2</span>(N), INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][K + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[ ++ tt] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j, u);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) ans += m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>) ans += <span class="number">1</span>;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        d[a] ++, d[b] ++, d[p] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图的强连通分量(SCC)</title>
    <url>/posts/31194034/</url>
    <content><![CDATA[<h1 id="有向图的强连通分量-SCC"><a href="#有向图的强连通分量-SCC" class="headerlink" title="有向图的强连通分量(SCC)"></a>有向图的强连通分量(SCC)</h1><blockquote>
<p>强连通分量 : SCC, 有向无环图 : DAG</p>
</blockquote>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><ul>
<li>默认前提为有向图。</li>
<li>连通分量：对于分量中的任意两点 u, v, 必然存在可以从 u 走到 v, 且从 v 走到 u 。</li>
<li>强连通分量 (SCC)：极大连通分量，(无法加入任何点的连通分量)</li>
</ul>
<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ul>
<li>将任意一个有向图，通过 缩点 ，转化为有向无环图(拓扑图，DAG)</li>
<li>缩点：将所有连通分量缩成一个点</li>
<li>好处是求最短路或最长路时，可以递推来做，时间复杂度为 线性: O(n + m)</li>
</ul>
<h2 id="Tarjan算法理论基础："><a href="#Tarjan算法理论基础：" class="headerlink" title="Tarjan算法理论基础："></a>Tarjan算法理论基础：</h2><ul>
<li>按照 DFS 的顺序来求</li>
<li>把边分为四类<ul>
<li>树枝边 (x, y)：x 是 y 的父节点</li>
<li>前向边 (x, y)：x 是 y 的祖先节点 (x -&gt; y)</li>
<li>后向边 (x, y): 指向祖先节点的边 (y -&gt; x)</li>
<li>横叉边 (x, y): 指向之前搜过的边</li>
</ul>
</li>
<li>如何判断一个点是否在强连通分量中？<ul>
<li>情况1：存在<strong>后向边</strong>直接指向祖先节点</li>
<li>情况2：通过<strong>横叉边</strong>的<strong>后向边</strong>走到祖先节点</li>
</ul>
</li>
</ul>
<h2 id="Tarjan算法求强连通分量-SCC-："><a href="#Tarjan算法求强连通分量-SCC-：" class="headerlink" title="Tarjan算法求强连通分量(SCC)："></a>Tarjan算法求强连通分量(SCC)：</h2><ul>
<li>时间戳(timestamp)：根据深度优先遍历的顺序给每个点编号；<ul>
<li>对每个点定义两个遍历到 u 的时间戳，<ul>
<li>dfn[u]: 遍历到 u 的时间</li>
<li>low[u]: u 可以遍历到的最小的时间戳</li>
<li>若 u 是其所在强连通分量的最高点，则 dfn[u] == low[u]，可知，u 的强连通分量中不可以加入任何点了，如此就找到了 u 所在的强连通分量。</li>
</ul>
</li>
<li>各种边的性质如下：<ul>
<li>树枝边: dfn[y] &gt; dfn[x];</li>
<li>前向边: dfn[y] &gt; dfn[x];</li>
<li>后向边: dfn[y] &lt; dfn[x];</li>
<li>横向边: dfn[y] &lt; dfn[x];</li>
</ul>
</li>
</ul>
</li>
<li>如何实现：背过板子即可  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> din[N], dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j]) <span class="comment">// 没遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历过，且没在任何连通分量中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈中当前点之后的点为一个强连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];  <span class="comment">// 取出栈顶</span></span><br><span class="line">            in_stk[y] = <span class="literal">false</span>; <span class="comment">// 不在栈中</span></span><br><span class="line">            scc_id[y] = scc_cnt;   <span class="comment">// 标记为第scc_cnt号强连通分量 </span></span><br><span class="line">            scc_size[scc_cnt] ++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>缩点：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> k = e[j];</span><br><span class="line">      <span class="type">int</span> a = scc_id[i], b = scc_id[k];</span><br><span class="line">      <span class="keyword">if</span>( a != b) dout[a] ++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>连通分量编号递减的顺序一定为拓扑序，(不用多写一步拓扑排序)<ul>
<li>证明：类似 tarjan 算法类似如下的 dfs 求 拓扑排序</li>
<li>dfs 求拓扑排序，seq[N] 的逆序一定为拓扑排序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> u 的所有邻点：</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    seq &lt;- u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可证得，对于 seq 中每个点 u 其后继节点在 seq 中的位置一定在 u 的前面</li>
</ul>
</li>
</ul>
<p>例题：<a href="https://www.acwing.com/problem/content/1176/">1174. 受欢迎的牛</a></p>
<h2 id="代码板子如下："><a href="#代码板子如下：" class="headerlink" title="代码板子如下："></a>代码板子如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line">            id[y] = scc_cnt;</span><br><span class="line">            scc_size[scc_cnt] ++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j];</span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k];</span><br><span class="line">            <span class="keyword">if</span>( a != b) dout[a] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">        &#123;</span><br><span class="line">            zeros ++;</span><br><span class="line">            sum += scc_size[i];</span><br><span class="line">            <span class="keyword">if</span>(zeros &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用结论及证明："><a href="#常用结论及证明：" class="headerlink" title="常用结论及证明："></a>常用结论及证明：</h2><blockquote>
<p>结论一：设一个图是非强连通分量，且 tarjan 算法得到的入度为0的点，即起点为P个，出度为0的点，即终点为Q个，把该图变为强连通分量(缩点缩成一个点)，最少需要加几条边？</p>
<p>答：最少需要新加 max(P, Q) 条边，特判掉若 P = Q == 1，则一个边都不用加。 </p>
</blockquote>
<h3 id="结论一证明："><a href="#结论一证明：" class="headerlink" title="结论一证明："></a>结论一证明：</h3><ul>
<li>分析可知 P &lt;= Q 的情况 和 P &gt;= Q 的情况类似，所以下面我们只证明 P &lt;= Q 的情况</li>
<li>当 P == 1 时，可知 P 可到达所有点，所以只需令 Q 个终点都与起点 P 连一条边，则所有路径的点都可以到达起点，即、所有点都可以到达所有点。答案为 Q ，满足 max(P, Q);</li>
<li>当 P &gt; 1 时，可知 Q &gt;= P &gt; 1，则前提 1：必然可以找到两个起点 P1, P2 和两个终点 Q1, Q2，使得 P1 -&gt; …… -&gt; Q1, P2 -&gt; …… -&gt; Q2，一定成立。<ul>
<li>简单证明前提 1：</li>
<li>反证法：如果找不到这样的两个点，则必然 Pi -&gt; …… -&gt; Q1 (解释，所有点都走向了 Q1 这个终点，但我们的终点不止 1 个，即、Q &gt; 1，则与已知条件矛盾)，所以必然有 一个 Pj -&gt; …… -&gt; Q2。</li>
</ul>
</li>
<li>从 Q1 连一条边向 P2 ，则 P —, Q — ，起点终点同时 -1。归纳为 加一条边 P, Q同时-1，若去掉 P - 1 次，则此时 P == 1，Q == Q - (P - 1)，此时由之前的 P == 1 的证明可知还需要再加 Q 条边，所以新加的边的总和为：P - 1 + Q - (P - 1) 即为 Q，满足 max(P, Q)</li>
<li>两种情况都成立，故结论成立，得证！</li>
</ul>
<p>例题：<a href="https://www.acwing.com/problem/content/1177/">1175. 最大半连通子图</a></p>
<blockquote>
<p>思路：缩点后找最长链(tarjan的强连通分量 + 背包问题求方案数)</p>
</blockquote>
<p>例题：<a href="https://www.acwing.com/problem/content/370/">368. 银河</a></p>
<blockquote>
<p>思路：强连通分量找正环 + 拓扑排序求最长路 </p>
</blockquote>
]]></content>
      <categories>
        <category>图论</category>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素 dijkstra 算法</title>
    <url>/posts/bc46f58a/</url>
    <content><![CDATA[<h1 id="朴素-Dijkstra-算法"><a href="#朴素-Dijkstra-算法" class="headerlink" title="朴素 Dijkstra 算法"></a>朴素 Dijkstra 算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>$O(n^2)$</li>
</ul>
<h2 id="算法应用情景："><a href="#算法应用情景：" class="headerlink" title="算法应用情景："></a>算法应用情景：</h2><ul>
<li>不含有负权边的图中</li>
</ul>
<h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><ul>
<li>初始化，将起点加入已更新的点中，并将起点的 <code>dist</code> 设为 0，其余点的 <code>dist</code> 为 INF，代表没更新</li>
<li>循环 <code>n - 1</code> 次，每次更新一个点，</li>
<li>用这个点更新其他点到起点的距离</li>
</ul>
<h2 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h2><p><img src="https://img-blog.csdnimg.cn/0921267586bb431fab5bc2e42a854077.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pm0X-aYjg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="朴素 $Dijkstra$ 算法"></p>
<h2 id="模板代码如下："><a href="#模板代码如下：" class="headerlink" title="模板代码如下："></a>模板代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 邻接矩阵，存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 先选中一个点，剩余 n - 1 个点，迭代 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"> </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h2><blockquote>
<p>$Dijkstra$ 算法严格规定一个点出队即为这个点的最短路，若一个点出队后，之后的点中有负权边，则之前的点应该被更新，但这个点已经出队，无法被更新，所以 $Dijkstra$ 系列算法都无法处理负权边的情况。</p>
</blockquote>
<h2 id="具体证明："><a href="#具体证明：" class="headerlink" title="具体证明："></a>具体证明：</h2><ul>
<li>如何证明最短路？仅需证明路径中的每一步都为当前的所有可行的道路中的最小值即可，每一步都最小，则所有步相加，必定可以使得结果最小，</li>
<li>$Dijkstra$ 算法正是如此，基于贪心的原理，每一次所走的路为当前可走的路中的最小值，所以可以增明最短路，</li>
<li>此外，还可以证明的是当一个点出队时，当前值即为从起点到该点的最短路，思路由数学归纳法可知，和证明终点为最短路类似，令该点为终点，可发现代码实现和原代码如出一辙，由此得证</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>朴素 Dijkstra 算法</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/posts/5ff58a77/</url>
    <content><![CDATA[<h1 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h1><p>例题：<a href="!https://www.acwing.com/problem/content/1150/">1148. 秘密的牛奶运输</a></p>
<blockquote>
<p>定理：对于一张无向图，如果存在最小生成树和(严格)次小生成树，那么对于任何一棵最小生成树，都存在一棵(严格)次小生成树，使得着两棵树只有一条边不同</p>
</blockquote>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><ul>
<li>先求最小生成树，再枚举删去最小生成树中的边求解。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>O(mlogm + nm)</li>
</ul>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><ul>
<li>化零为整：把最小生成树与次小生成树得不同得一条边分为n-1类(1~n-1)</li>
<li>只需求出每一类得最小值，则一定可以求出次小生成树</li>
</ul>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><ul>
<li>求非严格次小生成树可以，但求严格次小生成树不太方便</li>
</ul>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>先求最小生成树，然后依次枚举非树边，将该边加入树中，同时从树中去掉一条边，使得最终得图仍然是一棵树。则一定可以求出次小生成树。</li>
</ul>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>朴素算法 O(m + n^2 + mlogm))</li>
<li>lca 倍增优化 O(nlogn)</li>
</ul>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul>
<li>声明：<ul>
<li>设T为图G得一棵生成树，对于非树边a和树边b，插入边a，并删除边b的操作记为(+a,-b)。</li>
<li>如果T+a-b之后，仍然是一棵生成树，称(+a,-b)是T的一个可行交换。</li>
<li>由T进行一次可行变换所得到的新的生成树的集合称为T的邻集。</li>
</ul>
</li>
<li>定理：<ul>
<li>次小生成树一定再最小生成树的邻集中。</li>
</ul>
</li>
<li>证明如下：<ul>
<li>反证法：假设存在某一个图，次小生成树和最小生成树至少两条边不同。</li>
<li>先考虑非严格次小生成树：<ul>
<li>先最小生成树从小到大排序，枚举所有的最小生成树的边，枚举该边是否在次小生成树中，若不在，则将该边加上，形成环，去掉后面的边，权值小于等于之前的生成树，结果不会变坏，且次小生成树与最小生成树仍然由差异，则该操作成立，如此反复，直到次小生成树和最小生成树只剩一条边不同为止。</li>
</ul>
</li>
<li>再考虑严格次小生成树：<ul>
<li>类似上述操作，两边相等则不变(不用担心完全一样的问题，因为严格次小一定大于最小)，若当前枚举的最小生成树的边较小，则替换。如此可构造出只剩一条边不同的次小生成树</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="朴素代码如下；"><a href="#朴素代码如下；" class="headerlink" title="朴素代码如下；"></a>朴素代码如下；</h2><p>注意：在求严格次小生成树时，不能只预处理两点之间最大的树边，因为当最大树边和当前枚举的非树边长度相同时，就不能替换了，但此时却可以替换长度次大的树边。因此还需同时预处理出长度次大的树边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], w[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            edge[i].f = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> td1 = maxd1, td2 = maxd2;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; td1) td2 = td1, td1 = w[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i] &lt; td1 &amp;&amp; w[i] &gt; td2) td2 = w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(j, u, td1, td2, d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        p[i] = i;</span><br><span class="line">        </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist1[i], dist2[i]);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            LL t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(w &gt; dist1[a][b]) t = sum + w - dist1[a][b];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w &gt; dist2[a][b]) t = sum + w - dist2[a][b];</span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lca-倍增优化版代码如下："><a href="#lca-倍增优化版代码如下：" class="headerlink" title="lca 倍增优化版代码如下："></a>lca 倍增优化版代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d1[N][<span class="number">17</span>], d2[N][<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            edge[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = -INF, d2[j][k] = -INF;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span>(d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(a != b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k];</span><br><span class="line">                b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dist1 = -INF, dist2 = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist1) <span class="keyword">return</span> w - dist1;</span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist2) <span class="keyword">return</span> w - dist2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此返回值不会被用到</span></span><br><span class="line">    <span class="comment">// 当 dist1 无法被用时，dist2 一定小于 w </span></span><br><span class="line">    <span class="comment">// 证明：当 w == dist1 时：dist2 &lt; dist1；当 w &lt; dist1 时，dist2 &lt; dist1</span></span><br><span class="line">    <span class="comment">// 所以 w &gt; dist2 时一定成立的</span></span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>次小生成树</category>
      </categories>
      <tags>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法杂项</title>
    <url>/posts/66485649/</url>
    <content><![CDATA[<h1 id="算法杂项"><a href="#算法杂项" class="headerlink" title="算法杂项"></a>算法杂项</h1><h2 id="数论部分"><a href="#数论部分" class="headerlink" title="数论部分"></a>数论部分</h2><h3 id="两个数互质则不能由-p-q-凑出来的最大的数为-p-1-q-1-1"><a href="#两个数互质则不能由-p-q-凑出来的最大的数为-p-1-q-1-1" class="headerlink" title="两个数互质则不能由 p, q 凑出来的最大的数为 (p - 1) * (q - 1) - 1;"></a>两个数互质则不能由 p, q 凑出来的最大的数为 <code>(p - 1) * (q - 1) - 1;</code></h3><h2 id="平面直角坐标系部分"><a href="#平面直角坐标系部分" class="headerlink" title="平面直角坐标系部分"></a>平面直角坐标系部分</h2><h3 id="皮克定理："><a href="#皮克定理：" class="headerlink" title="皮克定理："></a>皮克定理：</h3><p><strong>定理：</strong> 皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式，该公式可以表示为 <code>S = a + b/2 - 1</code>，其中 a 表示多边形内部的点数，b 表示多边形落在格点边界上的点数，S 表示多边形的面积。</p>
<blockquote>
<p><strong>结论：</strong> s(面积) = a(中间的点) + b(边上的点) / 2 - 1</p>
</blockquote>
<h3 id="两点-x1-y1-x2-y2-的连线上的整点数-："><a href="#两点-x1-y1-x2-y2-的连线上的整点数-：" class="headerlink" title="两点(x1, y1)(x2, y2)的连线上的整点数 ："></a>两点(x1, y1)(x2, y2)的连线上的整点数 ：</h3><blockquote>
<p><strong>结论：</strong> <code>abs(gcd(x1 - x2, y1 - y2))</code></p>
</blockquote>
<p><strong>证明</strong> </p>
<ul>
<li>将该直线其中一点移动到原点(0, 0)，另一点为(a, b)，则该直线斜率为 b’ / a’ (约分过)，则该支线上的所有点一定为 <code>k * (b&#39; / a&#39;)</code>，k 可取 1, 2, 3, …… , gcd(a, b)。化为原坐标即为 <code>gcd(x1 - x2, y1 - y2)</code> , 因为 gcd 函数可能得负数，所以取 绝对值 abs()</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉回路和欧拉路径</title>
    <url>/posts/903ad369/</url>
    <content><![CDATA[<h1 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h1><p><strong>引入：</strong>哥尼斯堡七桥问题</p>
<p>欧拉路径 == 一笔画问题</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul>
<li>欧拉路径<ul>
<li>起点终点 度数为奇数</li>
<li>中间顶 度数为偶数</li>
</ul>
</li>
<li>对于无向图，所有边都是连通的<ul>
<li>存在欧拉路径的充分必要条件：度数(入读 + 出度)为奇数的点只能由0或2个。</li>
<li>存在欧拉回路的充分必要条件：度数为奇数的点为0个。</li>
</ul>
</li>
<li>对于有向图，所有边都是连通的<ul>
<li>存在欧拉路径的充分必要条件：所有点的出度均等于入度 或 除了两个点以外，其余所有点出度等于入度，剩余两个点 一个满足出度比入度多1（起点），一个满足入度比出度多1（终点）</li>
<li>存在欧拉回路的充分必要条件：所有点的出度均等于入度</li>
</ul>
</li>
</ul>
<h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><ul>
<li>左 -&gt; 右：已证明，右边本就是由左边推来的。</li>
<li>左 &lt;- 右：构造一种方案合法，即可证明<ul>
<li>直接 DFS ，遇到回路则进去转一圈出来，则一定可以走到终点，最终路径为一条线挂着许多环。 </li>
</ul>
</li>
</ul>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><p>seq数组保存路径，最终的路径是 seq 的逆序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> 从 u 出发的所有边</span><br><span class="line">    <span class="built_in">dfs</span>() <span class="comment">// 扩展</span></span><br><span class="line">seq &lt;- u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉回路的 dfs 遍历时，用边判重(used数组)，会导致时间复杂度较高(平方级别)，优化为 遍历一条边，删去一条边，即可保证为线性的复杂度。</p>
<p><strong>例题：</strong> <a href="https://www.acwing.com/problem/content/1126/">1124. 骑马修栅栏</a></p>
<p><strong>思路：</strong>欧拉回路找最小字典序即可</p>
<blockquote>
<p>如何保证最小字典序，从最小的点开始走。从最小的点开始走，则会最后回溯这个点，如此逆序即为字典序最小的序列。</p>
</blockquote>
<p><strong>代码如下：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">2100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">500</span>, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> ans[M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(g[u][i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] --, g[i][u] --;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    ans[ ++ cnt] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] ++, g[b][a] ++;</span><br><span class="line">        d[a] ++, d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!d[start]) start ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(d[i] % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">dfs</span>(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; i -- )</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>图论</category>
        <category>欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉回路</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛技巧</title>
    <url>/posts/777152b5/</url>
    <content><![CDATA[<h1 id="算法竞赛技巧"><a href="#算法竞赛技巧" class="headerlink" title="算法竞赛技巧"></a>算法竞赛技巧</h1><h2 id="防止最后卡空格-pta"><a href="#防止最后卡空格-pta" class="headerlink" title="防止最后卡空格(pta,,,)"></a>防止最后卡空格(pta,,,)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br></pre></td></tr></table></figure>
<p>*str = “ \n”;<br>解释:   当 i &lt; n, cout &lt;&lt; str[0]; ‘ ‘<br>        当 i == n, cout &lt;&lt; str[1]; ‘\n’</p>
<h2 id="竞赛缓解压力及做题顺序"><a href="#竞赛缓解压力及做题顺序" class="headerlink" title="竞赛缓解压力及做题顺序"></a>竞赛缓解压力及做题顺序</h2><ul>
<li>太紧张，可以吃一些东西，口香糖什么的，可以有效缓解压力</li>
<li>前两题较简单，看清题目，先做掉。</li>
<li>后面的题，若看很长时间了，仍然不会，打住！想暴力，那暴力分</li>
</ul>
<h2 id="防卡常"><a href="#防卡常" class="headerlink" title="防卡常"></a>防卡常</h2><ul>
<li>调用 <ctime> 函数库中的 clock()函数</li>
<li>clock()单位为 1e-6次方毫秒，1 clock() == 1e-6秒</li>
</ul>
<p>例子代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// clock()本身很慢，用 i%1000 == 0 来短路它避免频繁调用</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">clock</span>() - start &gt;= <span class="number">850000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>应试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理_期末复习</title>
    <url>/posts/f72ddf89/</url>
    <content><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章:"></a>第一章:</h1><h2 id="概念部分"><a href="#概念部分" class="headerlink" title="概念部分:"></a>概念部分:</h2><p>数据（Data）: 数据库中存储的基本对象<br>数据库（Database）: 长期储存在计算机内, 有组织的, 可共享的大量数据的集合<br>数据库管理系统（DBMS）: </p>
<ul>
<li>位于用户和操作系统之间的一层数据管理软件</li>
<li>是基础软件, 是一个大型的复杂的软件系统<br>数据库系统（DBS）:<br>  由数据库, 数据库管理系统(及其应用开发工具), 应用程序, 数据库管理员组成. </li>
</ul>
<p>区别和联系: </p>
<ol>
<li>数据库是计算机信息系统和应用系统的核心,是数据库管理系统处理的对象;</li>
<li>数据库管理系统是对计算机中所存放的大量数据进行组织、管理、查询并提供一定处理功能的大型系统软件,是用来处理数据库中的数据的软件;</li>
<li>数据库系统是数据库及其管理、维护和使用所需要的计算机硬件、软件和使用人员的总和,数据库和数据库管理系统属于数据库系统的一部分.</li>
</ol>
<p>数据库管理系统的功能: </p>
<ol>
<li>定义功能</li>
<li>操纵功能</li>
<li>控制弄能</li>
<li>其他</li>
</ol>
<p>市面上主流的数据库: </p>
<ol>
<li>Oracle</li>
<li>Sql server</li>
<li>Mysql</li>
<li>DB2</li>
<li>Access</li>
</ol>
<p>三个世界: </p>
<ol>
<li>现实世界</li>
<li>信息世界</li>
<li>机器世界</li>
</ol>
<p>两种模型:</p>
<ol>
<li>概念模型: 也称信息模型, 按照用户的观点, 对数据进行信息建模. <ul>
<li>三要素: 数据结构, 数据操作, 完整性约束</li>
</ul>
</li>
<li>逻辑模型 or 物理模型<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
</li>
</ol>
<p>E-R图: (Entity - Relationship diagram) 实体-联系图</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="概念部分-1"><a href="#概念部分-1" class="headerlink" title="概念部分"></a>概念部分</h2><p>域: 相同数据类型的集合</p>
<p>笛卡尔积: 所有域的所有取值的一个组合</p>
<p>关系: 笛卡尔积的子集 = 元组的集合</p>
<p>元组: 笛卡尔积中的每一个元素, 关系中的每个元素是关系中的元组</p>
<p>属性: 关系中不同列可以对应相同的域, 为了加以区分，必须对每列起一个名字，称为属性</p>
<p>键: 建立和标识表之间的关系,也用于唯一标识表中的任何记录或数据行</p>
<p>候选键: 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p>
<p>主键: 若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p>
<p>外键: 外部关键字, 不是本表的键, 但是其他表的键</p>
<p>数据模型的三个组成部分:</p>
<ul>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束</li>
</ul>
<p>关系模型的三要素:</p>
<ol>
<li>关系结构</li>
<li>关系操作</li>
<li>关系三类完整性约束条件<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户自定义的完整性</li>
</ul>
</li>
</ol>
<p>参照完整性中外键什么时候可以取空值，什么时候不能取空值 ? </p>
<p>答: 如果外键是键的一部分就不能取空值</p>
<p>关系代数部分:<br>模板:</p>
<ul>
<li>π 列名1, 列名2 σ 限制1 ∧ 限制2 (表1 ∞ 表2 ∞ 表3)</li>
</ul>
<p>注意:</p>
<ul>
<li>&lt;&gt; 不等于符号</li>
<li>➗ 用于至少, 或全部</li>
</ul>
<p>关系 = 二维表, 属性一列, 元组一行</p>
<h1 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h1><h2 id="定义语句"><a href="#定义语句" class="headerlink" title="定义语句:"></a>定义语句:</h2><p>create table, drop table<br>注意: </p>
<ul>
<li>primary key</li>
<li>foreign key</li>
<li>check, not null, unique</li>
<li>组合键: primary key (1, 2, 3)</li>
<li>外键: foreign key (列名) references 表名(列名)</li>
<li>约束: constraint 约束名 check(约束条件)</li>
<li>alter table 表名<br>add constraint 约束名 check(约束条件)</li>
</ul>
<h2 id="操纵语句"><a href="#操纵语句" class="headerlink" title="操纵语句:"></a>操纵语句:</h2><ul>
<li>insert into 表名(列名1, 列名2, 列名3)<br>values (‘’, ‘’, ‘’)</li>
<li>delete<br>from 表名<br>where 条件</li>
<li>update 表名<br>set (列名1 = ‘’, 列名2 = ‘’, 列名3 = ‘’)</li>
<li>select *<br>from 表 (inner join 表 on 条件)<br>where 条件<br>group by 列名</li>
<li>create view </li>
</ul>
<p>注意:</p>
<ul>
<li>order by () asc, 升序, desc 降序</li>
<li>group by 分组</li>
<li>having count(type) &gt;= 5</li>
</ul>
<p>视图部分: </p>
<p>所有的视图是否都可以更新？为什么？</p>
<ul>
<li>答:不是。视图是不实际存储数据的虚表，因此对视图的更新，最终要转换为对基本表的更<br>新。因为有些视图的更新不能惟一有意义地转换成对相应基本表的更新，所以，并不是所有<br>的视图都是可更新的.</li>
</ul>
<p>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</p>
<ul>
<li>答：基本表的行列子集视图一般是可更新的。若视图的属性来自集函数、表达式，则该视图<br>肯定是不可以更新的。</li>
</ul>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>安全性</p>
<ul>
<li>grant 权限<br>on 对象<br>to 角色</li>
<li>revoke 权限<br>on 对象<br>to 角色</li>
</ul>
<h1 id="第四章-安全性"><a href="#第四章-安全性" class="headerlink" title="第四章 安全性"></a>第四章 安全性</h1><p>数据库的安全性: </p>
<ul>
<li>保护数据库以防止不合法的使用所造成的数据泄露, 更改或损坏</li>
</ul>
<p>安全性控制的常用方法和技术</p>
<ol>
<li>用户标识和鉴别</li>
<li>存取控制</li>
<li>操作系统的安全性控制</li>
<li>数据加密</li>
<li>视图机制</li>
<li>审计</li>
</ol>
<p>自主存取控制:<br>    定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。</p>
<p>强制存取控制:<br>    每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p>
<p>例子: </p>
<ol>
<li>将 student 表和 class 表的所有权限授予用户 U1，同时使得 U1 拥有将获得权限授予他人<br>的权限<br>grant all privileges on Student,Class<br>to U1<br>with grant option;</li>
<li>每个职工只对自己的记录有 select 权力。<br>grant select on 职工<br>when user() = name</li>
</ol>
<p>理解并解释 MAC 机制中主体、客体、敏感度标记的含义。</p>
<ul>
<li>主体是系统中的活动实体，既包括 DBMS 所管理的实际用户，也包括代表用户的各进程。<br>客体是系统中的被动实体，是受主体操纵的，包括文件、基表、索引、视图等。对于主体和<br>客体，DBMS 为它们每个实例（值）指派一个敏感度标记（Label ）。<br>敏感度标记被分成若干级别，例如绝密（Top Secret ）、机密（Secret ）·可信( Confidential ）、<br>公开（PubliC ）等。主体的敏感度标记称为许可证级别（ClearanCe 玫 vel ) ，客体的敏感<br>度标记称为密级（Classification Level ）。</li>
</ul>
<p>什么是数据库的审计功能，为什么要提供审计功能？</p>
<ul>
<li>答：审计功能是指 DBMS 的审计模块在用户对数据库执行操作的同时把所有操作自动记录<br>到系统的审计日志中。</li>
</ul>
<h1 id="第五章-完整性"><a href="#第五章-完整性" class="headerlink" title="第五章 完整性"></a>第五章 完整性</h1><p>定义: 什么是数据库的完整性？</p>
<ul>
<li>数据库的完整性是指数据的正确性和相容性。</li>
</ul>
<p>完整性与安全性的差别:</p>
<ul>
<li>完整性措施的防范对象是不合语义的数据</li>
<li>安全性措施的防范对象是非法用户和非法操作</li>
</ul>
<p>什么是数据库的完整性约束</p>
<ul>
<li>完整性约束是指数据库中数据应该满足的语义约束条件</li>
</ul>
<p>常见的关系约束</p>
<ol>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义约束</li>
</ol>
<p>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一<br>般是如何分别进行处理的？</p>
<ul>
<li>违反 <strong>实体完整性</strong> 和 <strong>用户定义的完整性</strong> 时, 一般采用拒绝执行。</li>
<li>对于违反<strong>参照完整性</strong>的操作, 并不都是简单的拒绝执行, 有时要根据应用语义执行一些附加的操作, 以保证数据库的正确性(可能会 级联删除( CASCADES ) ; 受限删除( RESTRICTED ) ; 置空值删除( NULLIFIES ))。</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>不规范的模式引发的问题: </p>
<ul>
<li>原因是函数依赖</li>
</ul>
<p>函数依赖:</p>
<ul>
<li>依赖 = 蕴含(离散数学 “-&gt;”), True: 1-&gt;1, 0-&gt;1, 0-&gt;0; False: 1-&gt;0</li>
<li>如果 X-&gt;Y, 但 Y 不包含于 X, 则称 X-&gt;Y 是<strong>非平凡的函数依赖</strong><br>如果 X-&gt;Y, 但 Y 不包含于 X, 则称 X-&gt;Y 是<strong>平凡的函数依赖</strong><br>如果无特别说明, 则为 <strong>非平凡的函数依赖</strong></li>
</ul>
<p>判定范式: </p>
<ul>
<li>1NF: 不存在复合表</li>
<li>2NF: 所有非主属性都完全依赖于主键</li>
<li>3NF: 所有非主属性不传递依赖于其他非主属性</li>
<li>BCNF: 所有非主属性都完全依赖于候选键</li>
</ul>
<p>特判情况: </p>
<ol>
<li>任何一个二目关系是属于3NF: 因为关系模式中只有两个属性, 所以无传递</li>
<li>任何一个二目关系是属于BCNF: 按BCNF的定义, 若X, Y且Y不是X的子集时, 每个决定因素都包含码, 对于二目关系决定因素必然包含码</li>
<li>所有键为单属性的关系模式至少属于2NF: 因为键为单属性, 不会存在非主属性对键的部分依赖</li>
</ol>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>数据库设计的六个步骤:</p>
<ol>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>数据库物理设计</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ol>
<p>E-R图 -&gt; 设计表 -&gt; 判定范式</p>
<h1 id="第九章-查询优化"><a href="#第九章-查询优化" class="headerlink" title="第九章 查询优化"></a>第九章 查询优化</h1><p>数据查询中代数优化的基本原则是什么 ? </p>
<ul>
<li>选择运算尽可能先做, 尽量减少连接中表的大小</li>
</ul>
<p>选择运算的查询优化方法: 五点<br>表连接的查询优化方法: 三点</p>
<p>物理优化: 建立索引</p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><p>事务: 用户定义的一个数据库操作序列, 这些操作要么全做, 要么全不做, 是一个不可分割的工作单位<br>四个特性(ACID特性): 原子性(Atomicity), 一致性(Consistency), 隔离性(Isolation), 持续性(Durability)</p>
<ul>
<li>原子性：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事<br>务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持续性：持续性也称永久性（ Permanence），指一个事务一旦提交，它对数据库中数据的改变就<br>应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<p>数据库的故障: </p>
<ol>
<li>事务内部的故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒<br>其中: 事务故障, 系统故障, 介质故障影响事务的正常执行, 介质故障和计算机病毒破坏数据库数据</li>
</ol>
<p>数据库恢复的基本技术</p>
<ol>
<li>数据转储</li>
<li>登记日志文件</li>
</ol>
<p>数据转储: 当系统运行过程发生故障, 利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态</p>
<p>日志文件: 日志文件是用来记录事务对数据库的更新操作的文件。<br>登记日志文件时为什么必须先写日志文件，后写数据库？</p>
<ul>
<li>如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。</li>
</ul>
<p>事务故障恢复:<br>系统故障恢复:<br>介质故障恢复:<br>具有检查点的恢复技术:</p>
<h2 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h2><p>并发操作可能会产生哪几类数据不一致 ? </p>
<ol>
<li>丢失修改</li>
<li>不可重复读</li>
<li>读 “脏” 数据</li>
</ol>
<p>封锁: 封锁就是事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。<br>加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他的事务不能更新此数据<br>对象。</p>
<p>排他锁(X锁) : 排它锁又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>共享锁(S锁) : 共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p>
<p>活锁: </p>
<ul>
<li>产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务<strong>无限期等待某个封锁</strong>，从而导致活锁。</li>
<li>如何避免: 先来先服务</li>
</ul>
<p>死锁: </p>
<ul>
<li>在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求已被其他事务封锁的数据加锁，从而出现死等待。(T1封锁R1, 等待R2, T2封锁R2, 等待R1, 相互等待, 无限期)</li>
<li>如何避免: <ul>
<li>一次封锁法: 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li>
<li>顺序封锁法: 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li>
</ul>
</li>
</ul>
<p>并发调度的可串行性: </p>
<p>可串行化调度: </p>
<ul>
<li>多个事务的并发执行时正确的, 当且仅当其结果与按某一次序串行地执行这些事务时地结果相同</li>
</ul>
<p>什么样的并发调度是正确的调度？</p>
<ul>
<li>可串行化（ Serializable）的调度是正确的调度。</li>
</ul>
<p>两段锁协议: </p>
<ul>
<li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ul>
<p>“两段”的含义是，事务分为两个阶段：</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的<br>锁，但是不能释放任何锁。</li>
<li>第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务释放已经获得的锁，但是不能再申请任何<br>锁。</li>
</ul>
]]></content>
      <categories>
        <category>期末复习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01分数规划</title>
    <url>/posts/40edd48c/</url>
    <content><![CDATA[<h1 id="01分数规划"><a href="#01分数规划" class="headerlink" title="01分数规划"></a>01分数规划</h1><p>例题：<a href="https://www.acwing.com/problem/content/363/">spfa求负环 + 01分数规划</a></p>
<p>可参考如下博客：<a href="https://oi-wiki.org/misc/frac-programming/">分数规划</a></p>
<h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><ul>
<li>(一堆和) / (一堆和) 使其结果最大</li>
</ul>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ul>
<li>二分 [l, r]</li>
<li>f的和 / t的和 &gt; mid =&gt; f的和 &gt; mid <em> t的和 =&gt; (f[i] - mid </em> t[i])的和 &gt; 0 </li>
<li>最终 等价于图中是否存在正环？</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> wf[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], wt[M], ne[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + wf[t] - mid * wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + wf[t] - mid * wt[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        cin &gt;&gt; wf[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>01分数规划</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd思想和倍增思想</title>
    <url>/posts/2b475c23/</url>
    <content><![CDATA[<h1 id="Floyd思想和倍增思想"><a href="#Floyd思想和倍增思想" class="headerlink" title="Floyd思想和倍增思想"></a>Floyd思想和倍增思想</h1><p>例题：<a href="!https://www.acwing.com/problem/content/347/">345.牛站</a></p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^3*logm)</li>
</ul>
<h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li>Floyd思想：<ul>
<li>状态表示：d[K][i][j]为从i到j的经过前K条边的路径的最小值(与Floyd的d[n][i][j]经过前n个点的表示方法略有不同)</li>
<li>状态计算：d[K][i][j] = d[a][i][k] + d[b][k][j]，其中k为经过前a条边后的点，</li>
<li>更新一次可以增加两条边，更新两次增加三条边，如此我们仅需更新m-1次即可得到d[m][S][E]，时间复杂度为：O(n^3*m) n为200，m为1e6必定TLE</li>
<li>可以用倍增思想来将时间复杂度化为logm</li>
</ul>
</li>
<li>倍增思想(快速幂思想)<ul>
<li>最终路径类似于：S-&gt;x1-&gt;x2-&gt;x3-&gt;……-&gt;……-&gt;xm-1-&gt;E, 中间经过了m-1个点，m条边</li>
<li>我们可发现上述的路径先计算与后计算不会相互影响，即可以先计算中间的或先计算后面的，具有结合律，如此可借助倍增思想，仅需logm次即可找到合法路径</li>
<li>时间复杂度：O(n^3*logm)</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>哈希所有用过的点，包括起点和终点</li>
<li>倍增算法</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K, S, E;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> res[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> temp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k] + b[k][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(c, temp, <span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倍增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一条边都不走，i-&gt;i必须为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res[i][i] = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (K &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, g);</span><br><span class="line">        <span class="built_in">mul</span>(g, g, g);</span><br><span class="line">        K &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; m &gt;&gt; S &gt;&gt; E;</span><br><span class="line">    </span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ids;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(S)) ids[S] = ++ n;</span><br><span class="line">    <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(E)) ids[E] = ++ n;</span><br><span class="line">    S = ids[S], E = ids[E];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化自环为0，即经过一条边走到自身的权值为0，多此一举</span></span><br><span class="line">    <span class="comment">// 因为通过一条边的权值可能大于0，如果初始化为0，则之后的边无法在g中表现出来</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= N; i ++ )</span></span><br><span class="line">    <span class="comment">//     g[i][i] = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(a)) ids[a] = ++ n;</span><br><span class="line">        <span class="keyword">if</span> (!ids.<span class="built_in">count</span>(b)) ids[b] = ++ n;</span><br><span class="line">        a = ids[a], b = ids[b];</span><br><span class="line">        </span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qmi</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res[S][E] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>Floyd思想和倍增思想</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法求最小环</title>
    <url>/posts/20aed843/</url>
    <content><![CDATA[<h2 id="Floyd-算法求最小环"><a href="#Floyd-算法求最小环" class="headerlink" title="Floyd 算法求最小环"></a>Floyd 算法求最小环</h2><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>DP思路<ul>
<li>状态表示：化整为零：按照环上的最大点的编号来分类，可保证不重不漏</li>
<li>状态计算：枚举和最大点相邻的两点i,j同时使得dist[i][j]距离最小，即可保证最小环i-&gt;k-&gt;j-&gt;i的权值最小</li>
</ul>
</li>
<li>证明算法步骤2的正确性：<ul>
<li>若枚举到最大点k时，按照如上所述的方法找到最小环上的一个点大于k看，假设为k+2，则我们在该点k处用所有小于k的点i,j找到的最小环，一定不是全局的最优解，当我们枚举到 k+2 时，方可枚举到全局最小换，反证成立，则算法成立</li>
</ul>
</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>每次floyd更新最外层的k时，已知的路径中，只含0~k-1这些点更新的路径，如此可求得环上的最大值为k时的最小环。</li>
<li>求最小环权值：枚举与k相邻的i,j(小于k)，使dist[i][j]最小，即为环上最大点为k的最小环的权值，依次更新k直到k等于n，算法结束</li>
<li>求最小环路径：记录pos[i][j]为 [i, j] 区间，是由pos[i][j]更新而来，每次更新答案，递归求解路径</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> path[N], pos[N][N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = pos[l][r];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_path</span>(l, k);</span><br><span class="line">    path[cnt ++ ] = k;</span><br><span class="line">    <span class="built_in">get_path</span>(k, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((LL)d[i][j] + g[j][k] + g[k][i] &lt; res) <span class="comment">// i-&gt;k-&gt;j</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res = d[i][j] + g[j][k] + g[k][i];</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    path[cnt ++ ] = k;</span><br><span class="line">                    path[cnt ++ ] = i;</span><br><span class="line">                    <span class="built_in">get_path</span>(i, j);</span><br><span class="line">                    path[cnt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>Floyd算法求最小环</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>最小环问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal算法</title>
    <url>/posts/8708cb74/</url>
    <content><![CDATA[<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(mlogm)</li>
</ul>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>求朴素最小生成树</li>
<li>求最小生成森林，(求最小生成树的前一半)</li>
<li>已知一些边，求最小生成树(求最小生成树的后一半)</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>将所有边按照权重从小到大排序</li>
<li>枚举每条边的顶点a, b, 权重c，若a, b不在一个集合，则合并a, b集合, 反之则跳过，判断下一条边</li>
</ul>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>证明思路与prim算法类似。<ul>
<li>如何证明这条边一定可以被选？</li>
<li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会形成一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差。</li>
</ul>
</li>
<li>证明结论：若该边的两点所在的集合不同，则该边必定在最小生成树中</li>
<li>证明结论如下：<ul>
<li>反证法：假设没有选择该边x1，则必定选择了之后的边x2使得两集合合并，使之形成最小生成树</li>
<li>证明：把边x1加到用x2形成的最小生成树中，则会在形成一个环，且该边一定包含x1,x2，此时若把x2去除，则形成的也为一个生成树，且因为x1小于x2，新生成的生成树比原来的权值和还小，则可证x1比x2更合适，所以得证，若上述证明结论的情况发生，则必定成立！</li>
</ul>
</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kruskal 算法同样可以求最小生成森林（不全部连通的最小生成树）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b) p[a] = b;</span><br><span class="line">        <span class="keyword">else</span> res += edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>kruskal算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>kruskal算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Test01</title>
    <url>/posts/d3e5ea48/</url>
    <content><![CDATA[<p><a href="http://www.bilibili.com/">跳转到B站</a></p>
<h1 id="测试的文章"><a href="#测试的文章" class="headerlink" title="测试的文章"></a>测试的文章</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<p><strong>BP算法</strong></p>
<p>训练集    $\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}$</p>
<p>设    $\Delta_{i j}^{(l)}=0(\text { for all } l, i, j)$</p>
<p>$\begin{array}{l}{\text {For } i=1 \text { to } m}\end{array}$</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\text { Set } a^{(1)}=x^{(i)}} \\ {\text { Perform forward propagation to compute } a^{(l)} \text { for } l=2,3, \ldots, L} \\ {\text { Using } y^{(i)}, \text { compute } \delta^{(L)}=a^{(L)}-y^{(i)}} \\ {\text { Compute } \delta^{(L-1)}, \delta^{(l+1)}, \ldots, \delta^{(2)}} \\ {\Delta_{i j}^{(l)} :=\Delta_{i j}^{(l)}+a_{j}^{(l)} \delta_{i}^{(l+1)}}\end{array}</script><p>$\begin{array}{l}{D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}+\lambda \Theta_{i j}^{(l)}} &amp; {\text { if } j \neq 0} \\ {D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}} &amp; {\text { if } j=0}\end{array}$</p>
<p>其中    $\frac{\partial}{\partial \Theta_{i j}^{(l)}} J(\Theta)=D_{i j}^{(l)}$</p>
<hr>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>二分</tag>
        <tag>双指针</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim算法</title>
    <url>/posts/a72d76aa/</url>
    <content><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^2 + m)</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ul>
<li>邻接矩阵存边的权值</li>
<li>距离初始化为正无穷</li>
<li>每次选择当前集合终和外界所连边的权值最小的点</li>
<li>将该边所连的点扩展，并用刚扩展的点更新其他点到当前集合的权值</li>
</ul>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>证明思路与kruskal算法类似。<ul>
<li>如何证明这条边一定可以被选？</li>
<li>假设不选当前边，最终得到了一棵树。然后将这条边加上，那么必然会形成一个环，在这个环上，一定可以找出一条长度不小于当前边的边，那么把当前边替换上去，结果一定不会变差。</li>
</ul>
</li>
<li>证明结论：当前与外界直接相连的权值最小的一条边，这条边一定可以出现在最优解中。</li>
<li>证明过程如下：<ul>
<li>反证法：假设选择最小生成树的某一个状态集合x扩展某一个边x1(最小)时没有选择该边，选择了另一个边x2(非最小)，从而形成了一个生成树。</li>
<li>证明：已知集合x可扩展多个边x1, x2……x’等(权值升序排列)，选择了x2边扩展。若将x1边加入扩展了x2边而最终形成的生成树中，则必定会形成一个环，且该环上一定包含x’这条边，因为x1为扩展出来的权值最小的边，x’等其他边时扩展出来的非权值第一小边，则将x’去掉，x1加上，形成的还是一个生成树，且该生成树的总权值小于原来的生成树。如此，得证。</li>
</ul>
</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>prim算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>prim算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA求负环</title>
    <url>/posts/318426d0/</url>
    <content><![CDATA[<h1 id="SPFA求负环"><a href="#SPFA求负环" class="headerlink" title="SPFA求负环"></a>SPFA求负环</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>O(km)，最坏O(nm)</li>
</ul>
<h2 id="两种方法："><a href="#两种方法：" class="headerlink" title="两种方法："></a>两种方法：</h2><ul>
<li>法一：统计每个点入队的次数，如果某个点入队n次，则说明存在负环</li>
<li>法二：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数&gt;=n，则说明存在负环</li>
<li>都是基于抽屉原理（鸽巢原理）</li>
<li>一般用法二，时间复杂度更低</li>
</ul>
<h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><ul>
<li>为什么等价于将所有点入队？<br>解释：建立虚拟源点，并将虚拟源点和其他所有点连一条边</li>
<li>为什么求负环时不需要将其他点初始化为正无穷？<br>如果存在负环，则dist最终为-INF，所以dist无论时INF还是0无所谓，会绕负环无穷次，对于无穷而言具体的值就无所谓了。</li>
</ul>
<h2 id="关于TLE的优化"><a href="#关于TLE的优化" class="headerlink" title="关于TLE的优化"></a>关于TLE的优化</h2><ul>
<li>做题前要思考如何建图方便，因为spfa时间复杂度很危险，如何降低点和边的数量使关键</li>
<li>若时间复杂度接近O(nm)则可以默认其已经含有负环，具体可根据经验，(比如，当所有的入队次数超过2n时，我们就认为图中有很大可能时存在负环的)，缺点是不太稳定</li>
<li>将队列转化为栈，面对找负环的问题一般效率比较好，比上面的trick较稳定一些</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><p>队列 + trick(小花招): 200ms +</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m1, m2;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true有负环，false无负环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列改栈: 400ms+</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">700</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[tt -- ];</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[ ++ tt] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> str[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1010</span>;</span><br><span class="line">            <span class="keyword">while</span>(r - l &gt; <span class="number">1e-4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>SPFA求负环</category>
      </categories>
      <tags>
        <tag>spfa</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/posts/973bc934/</url>
    <content><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><h3 id="时间复杂度：O-n-m"><a href="#时间复杂度：O-n-m" class="headerlink" title="时间复杂度：O(n + m)"></a>时间复杂度：O(n + m)</h3><p><strong>算法实现：</strong>邻接表存储，dfs一遍，没染色，则染上色</p>
<h3 id="结论1："><a href="#结论1：" class="headerlink" title="结论1："></a>结论1：</h3><blockquote>
<p>一个图是二分图 == 图中不存在奇数环 == 染色法不存在矛盾</p>
</blockquote>
<p>p -&gt; q : p 是 q 的充分条件，q 是 p 的必要条件</p>
<p>假设 如上三个条件为 a == b == c</p>
<h3 id="证明1："><a href="#证明1：" class="headerlink" title="证明1："></a>证明1：</h3><ul>
<li>b 直接推 a 不太容易，所以 b -&gt; c - &gt; a </li>
<li>b -&gt; c ：<ul>
<li>反证法：假设图中不存在奇数环 但 染色法出现了矛盾。</li>
<li>假设第一个矛盾为两个白色相连，则在该连通块(环)中其他的点一定不存在矛盾，其染色一定为 白-黑-白-黑-……-白，首尾都为白，则符合我们的假设。如此一来，此连通块一定有奇数个点与已知反证法条件相矛盾，则原结论成立。</li>
</ul>
</li>
<li>c -&gt; b : <ul>
<li>反证法：如果染色的过程中不存在矛盾 但 图中存在奇数环</li>
<li>假设一个环的头为白色，有因为其是奇数环，则其尾一定也为白色，首尾都是白色，所以该图存在矛盾，原结论成立。</li>
</ul>
</li>
<li>(b, c) -&gt; a<ul>
<li>因为染色法不存在矛盾，则 白黑 相间连接，把白色黑色分别拿出，则构成二分图。</li>
</ul>
</li>
<li>a -&gt; (b, c)<ul>
<li>反证法：假设一个图是二分图，但图中存在奇数环</li>
<li>奇数环的任意一点出发，则与此点相连的点在另外一个集合中，依此类推，则最后会剩余两个相连的点，但却在同一个集合中，即、此图不是一个二分图，与反证法条件产生矛盾，则原结论成立。</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/259/">257. 关押罪犯</a></p>
<p><strong>思路：</strong>二分 + 染色法</p>
<ul>
<li>二分的两段性：假设 x 为最优解，即、x -&gt; 右的边可以构成二分图，若 x 向右移动，仍然可以构成二分图(二分图去掉一些边仍然是二分图，减去一些限制，更自由了)，左边一定不成立，应为 x 为当前的最优解，所以若 check(mid) == true，则当前的图可以构成二分图，向左移动看是否可以构成二分图，若恰好可以构成，则为最优解。</li>
</ul>
<h3 id="染色法-代码模板："><a href="#染色法-代码模板：" class="headerlink" title="染色法-代码模板："></a>染色法-代码模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 没染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匈牙利算法-增广路算法"><a href="#匈牙利算法-增广路算法" class="headerlink" title="匈牙利算法(增广路算法)"></a>匈牙利算法(增广路算法)</h2><h3 id="时间复杂度：O-n-m-1"><a href="#时间复杂度：O-n-m-1" class="headerlink" title="时间复杂度：O(n * m)"></a>时间复杂度：O(n * m)</h3><p><strong>作用：</strong>求二分图最大匹配数目</p>
<p><strong>思路：</strong>枚举一边，如果重复，看上一个能不能换</p>
<h3 id="基本概念-针对二分图所言"><a href="#基本概念-针对二分图所言" class="headerlink" title="基本概念(针对二分图所言)"></a>基本概念(针对二分图所言)</h3><ul>
<li>匹配：”任意两条边都没有公共端点”的边的集合，被称为图的一组匹配</li>
<li>最大匹配：包含边数最多的一组匹配，被称为二分图的最大匹配</li>
<li>匹配点：在匹配中的点</li>
<li>非匹配点：不在匹配中的点</li>
<li>增广路径：从非匹配点走，非匹配边，匹配边，非匹配边，匹配边，最终通过非匹配边走到了非匹配点，则该路径称为增广路径，增广路径可以使匹配的边数 + 1，匹配的点数 + 2</li>
</ul>
<h3 id="结论1：-1"><a href="#结论1：-1" class="headerlink" title="结论1："></a>结论1：</h3><blockquote>
<p>一个匹配是最大匹配 == 不存在增广路径</p>
</blockquote>
<h3 id="匈牙利算法-代码模板："><a href="#匈牙利算法-代码模板：" class="headerlink" title="匈牙利算法-代码模板："></a>匈牙利算法-代码模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;  <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;  <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集</span></span><br><span class="line">                             <span class="comment">// 合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];  <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图的覆盖与独立集"><a href="#二分图的覆盖与独立集" class="headerlink" title="二分图的覆盖与独立集"></a>二分图的覆盖与独立集</h2><p>包含的概念：最小点覆盖，最大独立集，最小路径点覆盖(特殊情况：最小路径重复点覆盖)</p>
<blockquote>
<p>结论：<strong>在二分图中</strong> 最大匹配数 == 最小点覆盖 == 总点数 - 最大独立集 == 总点数 - 最小路径点覆盖</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>最小点覆盖：给定一个图，求一个最小的点集 S ，使得图中任意一条边都至少一个端点属于 S。 </li>
<li>最大独立集：给定一个图，选出最多的点，使得选出的点之间没有边，等于补图的最大团。</li>
<li>最大团：给定一个图，选出最多的点，使得选出的点之间都有边，等于补图的最大独立集。</li>
<li>最小路径点覆盖(也称为最小路径覆盖): 在有向无环图(DAG)中，用最少的互不相交的路径(点和边都不重复)，将所有点覆盖住。</li>
</ul>
<h3 id="结论1-："><a href="#结论1-：" class="headerlink" title="结论1 ："></a>结论1 ：</h3><blockquote>
<p>在二分图中：最小点覆盖 == 最大匹配数</p>
</blockquote>
<h3 id="证明1：-1"><a href="#证明1：-1" class="headerlink" title="证明1："></a>证明1：</h3><ul>
<li>最小点覆盖 &gt;= 最大匹配数:<ul>
<li>一条边至少要选一个点，所以 最小点覆盖一定 &gt;= 最大匹配数</li>
</ul>
</li>
<li>最小点覆盖 == 最大匹配数：(证明<strong>等号</strong>可以成立) (构造)<ul>
<li>步骤如下：</li>
</ul>
<ol>
<li>求最大匹配</li>
<li>从左部每个非匹配点出发，做一遍增广，标记所有经过的点。则，<strong>左边所有未被标记的点，和右边所有被标记的点</strong> 即为 所求的匹配数。</li>
<li>可以发现以下的性质：<ol>
<li>左部所有非匹配点，一定被标记，</li>
<li>右部所有非匹配点一定未被标记(若右边的非匹配点被标记，此路径即为增广路径，非 - …… - 非，所以右部所有非匹配点一定未被标记)</li>
</ol>
</li>
<li>之后我们只需证明 <strong>所有边一定只有一个点被选</strong>即可。可以发现一共有四种边，左匹配 - 右匹配， 左非匹配 - 右匹配，左匹配 - 右非匹配，左非匹配 - 右非匹配</li>
<li>对于 <strong>左匹配 - 右匹配</strong> (匹配边) 而言，只有两种情况，<strong>同时被标记</strong> 和 <strong>同时不被标记</strong>，右边的点是随左边的点而变化。对于每个匹配而言，则左边所有未被标记的点，一定为匹配点，右边所有被标记的点，一定为匹配点。因此证明，对于每一条匹配边而言，如果左右同时被标记，则选择右边的点计数；如果左右两边同时不被标记，则选择左边的点计数，如此即可保证，对于每个匹配边，必定会选择其中一个点覆盖此边。</li>
<li>对于 <strong>左非匹配 - 右匹配</strong>，则右匹配点一定被标记，右匹配点一定被选，左非匹配点一定不被选。</li>
<li>对于 <strong>左匹配 - 右非匹配</strong>，则左匹配点一定未被标记，如此则右匹配点一定也未被标记，则我们会选择，左边未被标记的点，而右边的未被标记的点则一定不会被选。</li>
<li>对于 <strong>左非匹配 - 右非匹配</strong>，此情况一定不存在，因为此情况表示存在一条增广路径，原图做过最大匹配的算法了，则一定不存在增广路径。</li>
<li>如此我们即证明了，对于所有边一定有一个点且只有一个点被覆盖。</li>
</ol>
</li>
</ul>
<p><strong>例题1：</strong><a href="https://www.acwing.com/problem/content/378/">376. 机器任务</a></p>
<p><strong>思路：</strong>最小点覆盖 (匈牙利算法求最大匹配数即可)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; g[x][i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> t = match[i];</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span> || <span class="built_in">find</span>(t))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span>(k -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t, a, b;</span><br><span class="line">            cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(!a || !b) <span class="keyword">continue</span>;</span><br><span class="line">            g[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论2："><a href="#结论2：" class="headerlink" title="结论2："></a>结论2：</h3><blockquote>
<p>在二分图中，最大独立集 ==  总点数 - 最大匹配数</p>
</blockquote>
<h3 id="证明2："><a href="#证明2：" class="headerlink" title="证明2："></a>证明2：</h3><ul>
<li>最大独立集 == 去掉最少的点，将所有边都破坏掉，剩余的点的数量 == 总点数 - 最小点覆盖 == 总点数 - 最大匹配数</li>
</ul>
<p><strong>例题2：</strong> <a href="https://www.acwing.com/problem/content/380/">378. 骑士放置</a></p>
<p><strong>思路：</strong>最大独立集</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">1</span> || a &gt; n || b &lt; <span class="number">1</span> || b &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b] || g[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        PII t = match[a][b];</span><br><span class="line">        <span class="keyword">if</span>(!t.x || <span class="built_in">find</span>(t.x, t.y))</span><br><span class="line">        &#123;</span><br><span class="line">            match[a][b] = &#123;x, y&#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) % <span class="number">2</span> || g[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i, j)) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; n * m - k - res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论3："><a href="#结论3：" class="headerlink" title="结论3："></a>结论3：</h3><blockquote>
<p>在二分图中，最大匹配数 == 总点数 - 最小路径点覆盖</p>
</blockquote>
<h3 id="证明3："><a href="#证明3：" class="headerlink" title="证明3："></a>证明3：</h3><ul>
<li>结论转化为：最小路径点覆盖 = 总点数 - 最大匹配数</li>
<li>最小路径点覆盖如何实现：<ul>
<li>用拆点实现：一个点拆为两个点 入点i 和 出点i ，做完最小路径点覆盖，得到的图是二分图， 入点和出点的集合一定在两侧。</li>
</ul>
</li>
<li>原图的路径 转化到 新图(拆完点的图)中为：新图中的边必然无公共点，原路径对应新图的一个匹配</li>
<li>原图的路径终点 在新图中没有出边，等价于 左部的非匹配点，则原证明可以转化为：让左侧的非匹配点最少(n-m)，等价于 让左侧的匹配点最多(m) 等价于 找最大匹配(m)</li>
</ul>
<h3 id="结论4："><a href="#结论4：" class="headerlink" title="结论4："></a>结论4：</h3><blockquote>
<p>在二分图中，最大匹配数 == 总点数 - 最小路径<strong>重复</strong>点覆盖(是最小路径点覆盖的扩展)</p>
</blockquote>
<h3 id="证明4："><a href="#证明4：" class="headerlink" title="证明4："></a>证明4：</h3><ul>
<li>先求传递闭包，则 原图的最小路径重复点覆盖 可以转化为 新图的最小路径点覆盖(新结论)</li>
<li>证明新结论：</li>
<li>左 -&gt; 右：如果原图的路径有交集，则直接跳过交集的部分，一直跳过，直到无交集位置，如此即为新图上的最小路径点覆盖</li>
<li>左 &lt;- 右：将新图的间接边转化为原图的直接边，则可以成立。</li>
</ul>
<p><strong>例题：</strong> <a href="https://www.acwing.com/problem/content/381/">379. 捉迷藏</a></p>
<p><strong>思路：</strong> 总点数 - 最小重复路径点覆盖 == 最大匹配数</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], st[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; g[x][i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> t = match[i];</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span> || <span class="built_in">find</span>(t))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                g[i][j] |= g[i][k] &amp; g[k][j];</span><br><span class="line">                </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; n - res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>染色法</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双端队列广搜</title>
    <url>/posts/88e344b2/</url>
    <content><![CDATA[<h1 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h1><h2 id="时间复杂度；"><a href="#时间复杂度；" class="headerlink" title="时间复杂度；"></a>时间复杂度；</h2><ul>
<li>每次从队列中取出队头为 $O(1)$</li>
<li>整体时间复杂度为线性的，即 $O(n + m)$</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>边权仅为0或1的图中</li>
</ul>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><p>(整体思路类似堆优化 $dijkstra$ 算法)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次取出队头，时间复杂度O(1)</span></span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!v) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法证明："><a href="#算法证明：" class="headerlink" title="算法证明："></a>算法证明：</h2><ul>
<li>类似堆优化 $dijkstra$ 算法，因为边权只有0和1，可以将0插入队头，1插入队尾，可以保证单调性的同时，将从优先队列中取出最小值的 $O(logm)$ 的步骤，优化为只取出队头的 $O(1)$ 操作，从而将时间复杂度降低为线性</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
        <category>双端队列广搜</category>
      </categories>
      <tags>
        <tag>双端队列广搜</tag>
      </tags>
  </entry>
  <entry>
    <title>传递闭包</title>
    <url>/posts/39d70f23/</url>
    <content><![CDATA[<h1 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>O(n^3)</li>
</ul>
<h2 id="算法解释：若-a-gt-b-b-gt-c-则-a-gt-c，将所有的间接到的点化为直接到，如此称为传递闭包"><a href="#算法解释：若-a-gt-b-b-gt-c-则-a-gt-c，将所有的间接到的点化为直接到，如此称为传递闭包" class="headerlink" title="算法解释：若 a-&gt;b, b-&gt;c 则 a-&gt;c，将所有的间接到的点化为直接到，如此称为传递闭包"></a>算法解释：若 a-&gt;b, b-&gt;c 则 a-&gt;c，将所有的间接到的点化为直接到，如此称为传递闭包</h2><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>直接Floyd算法</li>
<li>更新距离的函数变一下即可</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] |= d[i][k] &amp; d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>传递闭包</category>
      </categories>
      <tags>
        <tag>floyd</tag>
        <tag>传递闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/posts/417dcd30/</url>
    <content><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>用最短路算法(spfa)实现</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>求不等式组的可行解</li>
<li>如何求最大值和最小值</li>
</ol>
<h2 id="知识点如下；"><a href="#知识点如下；" class="headerlink" title="知识点如下；"></a>知识点如下；</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/09/03/142813_94cfc2962b-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F.png" alt="差分约束"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/03/142813_dd59e5382b-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F_2.png" alt="差分约束"></p>
<ul>
<li>差分约束如何建图：</li>
<li>首先明确，求最短路用 <code>i &lt;= j + x</code> 来更新距离，含义为 j-&gt;i 边权为x，文字表示为i可用j来更新，求最长路用 <code>i &gt;= j + x</code> 来更新距离，同理。</li>
<li>求最小值( &gt;= x的最小值)，所有的不等式化为<code>i &gt;= j + x</code>，添边:add(j, i, x)，求x0到每个点xi的最长路。</li>
<li>求最大值( &lt;= x的最大值)，所有的不等式化为<code>i &lt;= j + x</code>，添边为add(j, i, x)，求x0到每个点xi的最短路，</li>
</ul>
<p><strong>注意：</strong>若涉及区间和的问题，考虑前缀和，转化为两点之间的关系</p>
<h2 id="例题：1169-糖果"><a href="#例题：1169-糖果" class="headerlink" title="例题：1169. 糖果"></a>例题：<a href="https://www.acwing.com/problem/content/1171/">1169. 糖果</a></h2><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 1, A &gt;= B &amp;&amp; B &gt;= A</span></span><br><span class="line"><span class="comment">x = 2, B &gt;= A + 1</span></span><br><span class="line"><span class="comment">x = 3, A &gt;= B</span></span><br><span class="line"><span class="comment">x = 4, A &gt;= B + 1</span></span><br><span class="line"><span class="comment">x = 5, B &gt;= A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[-- tt];</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>), <span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">add</span>(a, b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) <span class="built_in">add</span>(b, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>()) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            res += dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/fb40efc5/</url>
    <content><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><ul>
<li>在一个有向图中，对所有节点排序后，对于每一条边都是前面指向后面，没有由后面指向前面的边，则称新的序列为有向图的拓扑排序。若有向图存在环，必然没有拓扑排序；若有向图无环，则必然存在一个拓扑排序。</li>
<li>如果一个图是可以拓扑排序的，则称此图为拓扑图 == 有向无环图(DAG)</li>
</ul>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><ul>
<li>将所有入读为0的点入队<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (q 非空)</span><br><span class="line">&#123;</span><br><span class="line">  t &lt;- q的头节点</span><br><span class="line">  <span class="keyword">for</span> t 的所有出边 t -&gt; j</span><br><span class="line">  &#123;</span><br><span class="line">      -- d[j];</span><br><span class="line">      <span class="keyword">if</span> (d[j] == <span class="number">0</span>) q &lt;- j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="算法模板如下："><a href="#算法模板如下：" class="headerlink" title="算法模板如下："></a>算法模板如下：</h2><p>如果求字典序最小的拓扑排序，将 队列换成优先队列即可。</p>
<p>当前队列的元素为 度数为0 的点，当前序列中的点一定为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>( -- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理_期末复习</title>
    <url>/posts/f72ddf89/</url>
    <content><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章:"></a>第一章:</h1><h2 id="概念部分"><a href="#概念部分" class="headerlink" title="概念部分:"></a>概念部分:</h2><p>数据（Data）: 数据库中存储的基本对象<br>数据库（Database）: 长期储存在计算机内, 有组织的, 可共享的大量数据的集合<br>数据库管理系统（DBMS）: </p>
<ul>
<li>位于用户和操作系统之间的一层数据管理软件</li>
<li>是基础软件, 是一个大型的复杂的软件系统<br>数据库系统（DBS）:<br>  由数据库, 数据库管理系统(及其应用开发工具), 应用程序, 数据库管理员组成. </li>
</ul>
<p>区别和联系: </p>
<ol>
<li>数据库是计算机信息系统和应用系统的核心,是数据库管理系统处理的对象;</li>
<li>数据库管理系统是对计算机中所存放的大量数据进行组织、管理、查询并提供一定处理功能的大型系统软件,是用来处理数据库中的数据的软件;</li>
<li>数据库系统是数据库及其管理、维护和使用所需要的计算机硬件、软件和使用人员的总和,数据库和数据库管理系统属于数据库系统的一部分.</li>
</ol>
<p>数据库管理系统的功能: </p>
<ol>
<li>定义功能</li>
<li>操纵功能</li>
<li>控制功能</li>
<li>其他</li>
</ol>
<p>市面上主流的数据库: </p>
<ol>
<li>Oracle</li>
<li>Sql server</li>
<li>Mysql</li>
<li>DB2</li>
<li>Access</li>
</ol>
<p>三个世界: </p>
<ol>
<li>现实世界</li>
<li>信息世界</li>
<li>机器世界</li>
</ol>
<p>两种模型:</p>
<ol>
<li>概念模型: 也称信息模型, 按照用户的观点, 对数据进行信息建模. <ul>
<li>三要素: 数据结构, 数据操作, 完整性约束</li>
</ul>
</li>
<li>逻辑模型 or 物理模型<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
</li>
</ol>
<p>E-R图: (Entity - Relationship diagram) 实体-联系图</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="概念部分-1"><a href="#概念部分-1" class="headerlink" title="概念部分"></a>概念部分</h2><p>域: 相同数据类型的集合</p>
<p>笛卡尔积: 所有域的所有取值的一个组合</p>
<p>关系: 笛卡尔积的子集 = 元组的集合</p>
<p>元组: 笛卡尔积中的每一个元素, 关系中的每个元素是关系中的元组</p>
<p>属性: 关系中不同列可以对应相同的域, 为了加以区分，必须对每列起一个名字，称为属性</p>
<p>键: 建立和标识表之间的关系,也用于唯一标识表中的任何记录或数据行</p>
<p>候选键: 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p>
<p>主键: 若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p>
<p>外键: 外部关键字, 不是本表的键, 但是其他表的键</p>
<p>数据模型的三个组成部分:</p>
<ul>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束</li>
</ul>
<p>关系模型的三要素:</p>
<ol>
<li>关系结构</li>
<li>关系操作</li>
<li>关系三类完整性约束条件<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户自定义的完整性</li>
</ul>
</li>
</ol>
<p>参照完整性中外键什么时候可以取空值，什么时候不能取空值 ? </p>
<p>答: 如果外键是键的一部分就不能取空值</p>
<p>关系代数部分:<br>模板:</p>
<ul>
<li>π 列名1, 列名2 σ 限制1 ∧ 限制2 (表1 ∞ 表2 ∞ 表3)</li>
</ul>
<p>注意:</p>
<ul>
<li>&lt;&gt; 不等于符号</li>
<li>➗ 用于至少, 或全部</li>
</ul>
<p>关系 = 二维表, 属性一列, 元组一行</p>
<h1 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h1><h2 id="定义语句"><a href="#定义语句" class="headerlink" title="定义语句:"></a>定义语句:</h2><p>create table, drop table<br>注意: </p>
<ul>
<li>primary key</li>
<li>foreign key</li>
<li>check, not null, unique</li>
<li>组合键: primary key (1, 2, 3)</li>
<li>外键: foreign key (列名) references 表名(列名)</li>
<li>约束: constraint 约束名 check(约束条件)</li>
<li>alter table 表名<br>add constraint 约束名 check(约束条件)</li>
</ul>
<h2 id="操纵语句"><a href="#操纵语句" class="headerlink" title="操纵语句:"></a>操纵语句:</h2><ul>
<li>insert into 表名(列名1, 列名2, 列名3)<br>values (‘’, ‘’, ‘’)</li>
<li>delete<br>from 表名<br>where 条件</li>
<li>update 表名<br>set 列名1 = ‘’, 列名2 = ‘’, 列名3 = ‘’<br>from (若更改其他表中的外键, 需要将这几个表联合起来)<br>where </li>
<li>select *<br>from 表 (inner join 表 on 条件)<br>where 条件<br>group by 列名</li>
<li>create view </li>
</ul>
<p>注意:</p>
<ul>
<li>order by () asc, 升序, desc 降序</li>
<li>group by 分组</li>
<li>having count(type) &gt;= 5</li>
</ul>
<p>视图部分: </p>
<p>所有的视图是否都可以更新？为什么？</p>
<ul>
<li>答:不是。视图是不实际存储数据的虚表，因此对视图的更新，最终要转换为对基本表的更<br>新。因为有些视图的更新不能惟一有意义地转换成对相应基本表的更新，所以，并不是所有<br>的视图都是可更新的.</li>
</ul>
<p>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</p>
<ul>
<li>答：基本表的行列子集视图一般是可更新的。若视图的属性来自集函数、表达式，则该视图<br>肯定是不可以更新的。</li>
</ul>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>安全性</p>
<ul>
<li>grant 权限<br>on 对象<br>to 角色</li>
<li><p>revoke 权限<br>on 对象<br>from 角色</p>
</li>
<li><p>使用SQL语句完成以下操作：将“数据库”成绩的查询权、成绩字段的修改权授予除用户Gary之外的所有用户；</p>
</li>
<li>答: </li>
</ul>
<p>create view v1<br>as<br>select *<br>from </p>
<h1 id="第四章-安全性"><a href="#第四章-安全性" class="headerlink" title="第四章 安全性"></a>第四章 安全性</h1><p>数据库的安全性: </p>
<ul>
<li>保护数据库以防止不合法的使用所造成的数据泄露, 更改或损坏</li>
</ul>
<p>安全性控制的常用方法和技术</p>
<ol>
<li>用户标识和鉴别</li>
<li>存取控制</li>
<li>操作系统的安全性控制</li>
<li>数据加密</li>
<li>视图机制</li>
<li>审计</li>
</ol>
<p>自主存取控制:<br>    定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。</p>
<p>强制存取控制:<br>    每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p>
<p>例子: </p>
<ol>
<li>将 student 表和 class 表的所有权限授予用户 U1，同时使得 U1 拥有将获得权限授予他人<br>的权限<br>grant all privileges on Student,Class<br>to U1<br>with grant option;</li>
<li>每个职工只对自己的记录有 select 权力。<br>grant select on 职工<br>when user() = name</li>
</ol>
<p>理解并解释 MAC 机制中主体、客体、敏感度标记的含义。</p>
<ul>
<li>主体是系统中的活动实体，既包括 DBMS 所管理的实际用户，也包括代表用户的各进程。<br>客体是系统中的被动实体，是受主体操纵的，包括文件、基表、索引、视图等。对于主体和<br>客体，DBMS 为它们每个实例（值）指派一个敏感度标记（Label ）。<br>敏感度标记被分成若干级别，例如绝密（Top Secret ）、机密（Secret ）·可信( Confidential ）、<br>公开（PubliC ）等。主体的敏感度标记称为许可证级别（ClearanCe 玫 vel ) ，客体的敏感<br>度标记称为密级（Classification Level ）。</li>
</ul>
<p>什么是数据库的审计功能，为什么要提供审计功能？</p>
<ul>
<li>答：审计功能是指 DBMS 的审计模块在用户对数据库执行操作的同时把所有操作自动记录<br>到系统的审计日志中。</li>
</ul>
<h1 id="第五章-完整性"><a href="#第五章-完整性" class="headerlink" title="第五章 完整性"></a>第五章 完整性</h1><p>定义: 什么是数据库的完整性？</p>
<ul>
<li>数据库的完整性是指数据的正确性和相容性。</li>
</ul>
<p>完整性与安全性的差别:</p>
<ul>
<li>完整性措施的防范对象是不合语义的数据</li>
<li>安全性措施的防范对象是非法用户和非法操作</li>
</ul>
<p>什么是数据库的完整性约束</p>
<ul>
<li>完整性约束是指数据库中数据应该满足的语义约束条件</li>
</ul>
<p>常见的关系约束</p>
<ol>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义约束</li>
</ol>
<p>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一<br>般是如何分别进行处理的？</p>
<ul>
<li>违反 <strong>实体完整性</strong> 和 <strong>用户定义的完整性</strong> 时, 一般采用拒绝执行。</li>
<li>对于违反<strong>参照完整性</strong>的操作, 并不都是简单的拒绝执行, 有时要根据应用语义执行一些附加的操作, 以保证数据库的正确性(可能会 级联删除( CASCADES ) ; 受限删除( RESTRICTED ) ; 置空值删除( NULLIFIES ))。</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>不规范的模式引发的问题: </p>
<ul>
<li>原因是函数依赖</li>
</ul>
<p>函数依赖:</p>
<ul>
<li>依赖 = 蕴含(离散数学 “-&gt;”), True: 1-&gt;1, 0-&gt;1, 0-&gt;0; False: 1-&gt;0</li>
<li>如果 X-&gt;Y, 但 Y 不包含于 X, 则称 X-&gt;Y 是<strong>非平凡的函数依赖</strong><br>如果 X-&gt;Y, 但 Y 不包含于 X, 则称 X-&gt;Y 是<strong>平凡的函数依赖</strong><br>如果无特别说明, 则为 <strong>非平凡的函数依赖</strong></li>
</ul>
<p>判定范式: </p>
<ul>
<li>1NF: 不存在复合表</li>
<li>2NF: 所有非主属性都完全依赖于候选键(码)</li>
<li>3NF: 所有非主属性不传递依赖于其他非主属性</li>
<li>BCNF: 所有主属性不传递依赖于其他属性</li>
</ul>
<p>特判情况: </p>
<ol>
<li>任何一个二目关系是属于3NF: 因为关系模式中只有两个属性, 所以无传递</li>
<li>任何一个二目关系是属于BCNF: 按BCNF的定义, 若X, Y且Y不是X的子集时, 每个决定因素都包含码, 对于二目关系决定因素必然包含码</li>
<li>所有键为单属性的关系模式至少属于2NF: 因为键为单属性, 不会存在非主属性对键的部分依赖</li>
</ol>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>数据库设计的六个步骤:</p>
<ol>
<li>需求分析: 准确了解与分析用户需求（包括数据与处理）。</li>
<li>概念结构设计: E-R图</li>
<li>逻辑结构设计: 表设计</li>
<li>数据库物理设计: 数据的存储和存取</li>
<li>数据库实施: 建立数据库, 运行调试</li>
<li>数据库运行和维护: 运行过程对其评价, 调整和修改</li>
</ol>
<p>E-R图 -&gt; 设计表 -&gt; 判定范式</p>
<h1 id="第九章-查询优化"><a href="#第九章-查询优化" class="headerlink" title="第九章 查询优化"></a>第九章 查询优化</h1><p>数据查询中代数优化的基本原则是什么 ? </p>
<ul>
<li>选择运算尽可能先做, 尽量减少连接中表的大小</li>
</ul>
<p>选择运算的查询优化方法: 五点<br>表连接的查询优化方法: 三点</p>
<p>物理优化: 建立索引</p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><p>事务: 用户定义的一个数据库操作序列, 这些操作要么全做, 要么全不做, 是一个不可分割的工作单位<br>四个特性(ACID特性): 原子性(Atomicity), 一致性(Consistency), 隔离性(Isolation), 持续性(Durability)</p>
<ul>
<li>原子性：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事<br>务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持续性：持续性也称永久性（ Permanence），指一个事务一旦提交，它对数据库中数据的改变就<br>应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<p>数据库的故障: </p>
<ol>
<li>事务内部的故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒<br>其中: 事务故障, 系统故障, 介质故障影响事务的正常执行, 介质故障和计算机病毒破坏数据库数据</li>
</ol>
<p>数据库恢复的基本技术</p>
<ul>
<li>数据库恢复的基本原理就是增加数据冗余</li>
</ul>
<ol>
<li>数据转储</li>
<li>登记日志文件</li>
</ol>
<p>数据转储: 当系统运行过程发生故障, 利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态</p>
<p>日志文件: 日志文件是用来记录事务对数据库的更新操作的文件。<br>登记日志文件时为什么必须先写日志文件，后写数据库？</p>
<ul>
<li>如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。</li>
</ul>
<p>事务故障恢复:<br>系统故障恢复:<br>介质故障恢复:<br>具有检查点的恢复技术:</p>
<h2 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h2><p>并发操作可能会产生哪几类数据不一致 ? </p>
<ol>
<li>丢失修改</li>
<li>不可重复读</li>
<li>读 “脏” 数据</li>
</ol>
<p>封锁: 封锁就是事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。<br>加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他的事务不能更新此数据<br>对象。</p>
<p>排他锁(X锁) : 排它锁又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>共享锁(S锁) : 共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p>
<p>活锁: </p>
<ul>
<li>产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务<strong>无限期等待某个封锁</strong>，从而导致活锁。</li>
<li>如何避免: 先来先服务</li>
</ul>
<p>死锁: </p>
<ul>
<li>在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求已被其他事务封锁的数据加锁，从而出现死等待。(T1封锁R1, 等待R2, T2封锁R2, 等待R1, 相互等待, 无限期)</li>
<li>如何避免: <ul>
<li>一次封锁法: 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li>
<li>顺序封锁法: 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li>
</ul>
</li>
</ul>
<p>并发调度的可串行性: </p>
<p>可串行化调度: </p>
<ul>
<li>多个事务的并发执行时正确的, 当且仅当其结果与按某一次序串行地执行这些事务时地结果相同</li>
</ul>
<p>什么样的并发调度是正确的调度？</p>
<ul>
<li>可串行化（ Serializable）的调度是正确的调度。</li>
</ul>
<p>两段锁协议: </p>
<ul>
<li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ul>
<p>“两段”的含义是，事务分为两个阶段：</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的<br>锁，但是不能释放任何锁。</li>
<li>第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务释放已经获得的锁，但是不能再申请任何<br>锁。</li>
</ul>
]]></content>
      <categories>
        <category>期末复习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-期末复习</title>
    <url>/posts/93f21a/</url>
    <content><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><blockquote>
<p>栈的排列方式:</p>
</blockquote>
<p>n个不同的元素进栈, 出栈元素不同排列的个数为 </p>
<p>$\frac{1}{n+1}C_{2n}^n$</p>
<blockquote>
<p>堆顶栈</p>
</blockquote>
<p>栈满条件: top0 + 1 = top1 (无论是否从0或1开始)</p>
<blockquote>
<p>循环队列判断队满的情况: </p>
</blockquote>
<p>(q.rear + 1) % Maxsize == q.front</p>
<blockquote>
<p>栈和队列的异同点</p>
</blockquote>
<p>栈和队列都是加了限制的线性表,栈是先进后出表,队列是先进先出表。栈和队列的插入和删除操作都在端点进行,栈的插入和删除在同一端点,队列的插入和删除在不同的端点进行。</p>
<blockquote>
<p>首元结点, 头结点, 头指针的区别</p>
</blockquote>
<ol>
<li>首元结点（First Node）：链表中的首元结点是指链表中第一个实际存储数据的结点。它是链表中第一个具有数据域和指针域的结点，用来存储链表中的第一个元素。</li>
<li>头结点（Head Node）：头结点是在链表中添加的一个额外的结点，位于链表的前面，不存储实际的数据。头结点的作用是为了方便链表的操作和管理，它可以包含一些附加信息，如链表的长度等。</li>
<li><p>头指针（Head Pointer）：头指针是指向头结点的指针，它是链表的入口。通过头指针，可以找到整个链表的起始位置。头指针用来记录链表的基地址，在进行链表的遍历、插入、删除等操作时，可以通过头指针来进行操作。</p>
</li>
<li><p>首元结点是链表中的第一个实际存储数据的结点。</p>
</li>
<li>头结点是在链表中添加的一个额外结点，用于方便链表的操作和管理，不存储实际的数据。</li>
<li>头指针是指向头结点的指针，用来记录链表的基地址。</li>
</ol>
<blockquote>
<p>哈希表</p>
</blockquote>
<p>假设哈希表长为m，p为小于等于m的最大质数，则哈希函数为<br>H(key) = key % p</p>
<p>哈希表平均查找长度</p>
<p>查找成功的平均查找长度:<br>ASLsucc = 查找次数 / 元素个数</p>
<p>查找失败的平均查找长度:<br>ASLunsucc = 查找次数 /  散列后的地址长度(p)</p>
<blockquote>
<p>拓扑排序 </p>
<p>关联路径求法: </p>
</blockquote>
<p><img src="../myimages/关键路径.png" alt="关键路径"></p>
<p><a href="https://blog.csdn.net/qq_44528283/article/details/120384101">看这篇博客理解</a></p>
<p>具体步骤: </p>
<ol>
<li>令ve(源点) = 0, 求最早的发生时间ve()</li>
<li>令vl(汇点) = ve(汇点), 求最迟的发生时间vl()</li>
<li>根据ve()值求所有点的最早开始时间ve()</li>
<li>根据每个点的最早开始时间ve(), 求弧的最早开始时间e()</li>
<li>根据vl()值求所有点的最迟开始时间vl()</li>
<li>根据每个点的最迟开始时间vl(), 求弧的最迟开始时间l()</li>
<li>求AOE网中所有活动的差额d(), 找出所有 d() = 0 的活动构成关键路径</li>
</ol>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote>
<p>如何判断序列是否执行了快速排序: </p>
</blockquote>
<p>要点: 每经过一次快速排序, 轴点元素都必然就位。也就是说, 一趟排序至少有一个元素在其最终位置上</p>
<p><a href="https://blog.csdn.net/sinat_42483341/article/details/109281275">快速排序判断</a></p>
<p>最终排序位置是：2, 5, 12, 16, 28, 32, 60, 72，而选项中正确的位置有：</p>
<p>A. 5, 2, 16, 12, 28, 60, 32, 72<br>B. 2, 16, 5, 28, 12, 60, 32, 72<br>C. 2, 12, 16, 5, 28, 32, 72, 60<br>D. 5, 2, 12, 28, 16, 32, 72, 60</p>
<p>第一趟排序，确定一个元素位置<br>第二趟排序，又确定一个或两个元素位置<br>当第一趟元素确认的位置为最左或最右时，第二趟排序只能确认一个位置（A，B选项情况）<br>当第一趟元素确认位置不是最左或最右时，第二趟能确认2个位置（C选项情况）</p>
<p>线索二叉树: </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>无向图的双连通分量(DCC)</title>
    <url>/posts/b8105b5b/</url>
    <content><![CDATA[<h1 id="无向图的双连通分量-DCC"><a href="#无向图的双连通分量-DCC" class="headerlink" title="无向图的双连通分量(DCC)"></a>无向图的双连通分量(DCC)</h1><blockquote>
<p>可分为 边双连通分量(e-DCC) 与 点双连通分量(v-DCC)</p>
</blockquote>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>点双连通分量不一定是边双连通分量，边双连通分量也不一定是点双连通分量</li>
<li>割点与桥<strong>没有</strong>什么本质的关系</li>
<li>两个割点之间的边不一定是桥</li>
<li>一个桥的两个端点不一定是割点</li>
</ul>
<h2 id="边双连通分量-e-DCC"><a href="#边双连通分量-e-DCC" class="headerlink" title="边双连通分量(e-DCC)"></a>边双连通分量(e-DCC)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>桥：一条无向边，若删除此边，整个图变得不连通，则称这条边为“桥”。</li>
<li>边双连通分量：极大的不包含“桥”的连通块，则称为“边的双连通分量”</li>
<li>性质：<ol>
<li>无论删除哪一条边，整个图一定还是连通的</li>
<li>任意两点之间一定包含两条不相交的路径(边不相交)。</li>
</ol>
</li>
</ul>
<h3 id="Tarjan算法求边的双连通分量"><a href="#Tarjan算法求边的双连通分量" class="headerlink" title="Tarjan算法求边的双连通分量"></a>Tarjan算法求边的双连通分量</h3><ul>
<li>时间戳(timestamp)，dfn[N], low[N], 和有向图的强连通分量作用相同</li>
<li>如何找到桥？<ul>
<li>若子节点可以走到父节点或祖先节点，则从父节点到子节点的边不是桥，等价于，若边 x-y 为桥，则 dfn[x] &lt; low[y]</li>
</ul>
</li>
<li>如何找到边双连通分量？<ul>
<li>方法一：将所有桥删去</li>
<li>方法二：类似于有向图的强连通分量的Tarjan算法，用栈(stk数组)维护，刚开始搜索加到栈里，若dfs[i] == low[i]的话(即、i的父节点到i这条边为桥)，则i当前所在的子树中的节点即为当前边的双连通分量中的点。</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/397/">395. 冗余路径</a></p>
<p><strong>题意：</strong></p>
<p>给定一个无向连通图，<br>问：最少加几条边，使得任何两点之间都至少有两条边；等价于，最少加几条边，可以将其变成边双连通分量。</p>
<p><strong>结论1：</strong></p>
<blockquote>
<p>任何两点之间都至少有两条边；等价于，此图为边双连通分量</p>
</blockquote>
<p><strong>证明1：</strong></p>
<ul>
<li>充分性：左 -&gt; 右<ul>
<li>如果 任何两点之间都至少有两条边 则 此图是边双连通分量</li>
<li>反证法：假设任何两点之间都包含两条互不相交的路径，如果其不是边的双连通分量，则意味着这个图中，至少存在一个桥。</li>
<li>在桥两侧的连通块中任意找两个点x, y，则x到y的所有路径都经过桥这条边，所以x, y两点之间不存在两条互不相交的路径，与条件中的 任何两点直接按都包含两条互不相交的路径相矛盾，则假设不成立，原命题成立。</li>
</ul>
</li>
<li>必要性：左 &lt;- 右<ul>
<li>如果 此图是边双连通分量 则 任何两点之间都至少有两条边</li>
<li>左可推：此图不含桥，假设两点 x, y 则 x, y 的最短路径为连接 x, y 的一条边，对于该边中的每一段边，都可以直到这个边不是桥，则两个连通块之间必定有两外一条边，，基本思路为如此，具体证明y也不太清楚hh。</li>
</ul>
</li>
</ul>
<p><strong>结论2：</strong></p>
<blockquote>
<p>如果度数为 1 的点的个数为 cnt 个，则需要新加 (cnt + 1) / 2 条边，可以使得此图变为边的双连通分量。</p>
</blockquote>
<p><strong>证明2：</strong></p>
<ul>
<li>证明 ans &gt;= (cnt + 1) / 2 : 若此图边为边的双连通分量，等价于所有点的度数 &gt;= 2 , 即、所有度数为 1 的点都至少需要加一条边，最优先的连边策略为两个度数为 1 的点连一条边，消除两个度数为 1 的点，如果剩余一个点，此点随便连一个点即可，如此新加的边的个数的最优策略为 cnt / 2上取整，等价于 (cnt + 1) / 2 下取整，即所求新加的边 ans &gt;= (cnt + 1) / 2 (最优解)。</li>
<li>证明 ans == (cnt + 1) / 2 : 可知如果可以取到 (cnt + 1) / 2，则 我们所求的 ans == (cnt + 1) / 2; <ul>
<li>边界：当 只有两个点时，加一条边即可，(2 + 1) / 2 == 1 成立</li>
<li>至少有三个点：以一个度数至少为 2 的点为根节点，则所有度数为 1 的点都为叶子节点，两个叶子节点相连，剩余一个随便连，则新加的边的数量为 (cnt + 1) / 2，也成立。</li>
</ul>
</li>
<li>大致证明为以上的叙述，，具体证明太麻烦，就此告一段落，记住结论即可。</li>
</ul>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">int</span> dcc_id[N], dcc_cnt;</span><br><span class="line"><span class="type">bool</span> is_bridge[M];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from 为u是从哪条边来的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j, i); <span class="comment">// i 为边的编号</span></span><br><span class="line">            <span class="comment">// 关于此处为什么判断边?</span></span><br><span class="line">            <span class="comment">// 首先不可武断的判断是否为父节点父节点，我们要找的是边的双连通分量，两点之间可以有多条</span></span><br><span class="line">            <span class="comment">// 边，可能从 x - y 之间有 a, b 两条边，从 a 边下来，又从 b 边上去，这是可行的，若直接</span></span><br><span class="line">            <span class="comment">// 判断点，则 b 边是不可走，错误。</span></span><br><span class="line"></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] &lt; low[j])</span><br><span class="line">                is_bridge[i] = is_bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != (from ^ <span class="number">1</span>)) <span class="comment">// 边成对出现</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ dcc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];</span><br><span class="line">            dcc_id[y] = dcc_cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接判断所有边是不是桥，若是，则相邻的两条边的 e[i] 所在的 dcc_id都会加上 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(is_bridge[i])</span><br><span class="line">            d[dcc_id[e[i]]] ++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">1</span>) </span><br><span class="line">            cnt ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (cnt + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点双连通分量-v-DCC"><a href="#点双连通分量-v-DCC" class="headerlink" title="点双连通分量(v-DCC)"></a>点双连通分量(v-DCC)</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>割点：一个点，若删除此点，整个图变得不连通，则称这个点为“割点”</li>
<li>点双连通分量：极大的不包含“割点”的连通块，则称为“点的双连通分量”。</li>
<li>性质：<ol>
<li>每一个割点都会至少属于两个点双连通分量。 </li>
</ol>
</li>
</ul>
<h3 id="Tarjan算法求点的双连通分量"><a href="#Tarjan算法求点的双连通分量" class="headerlink" title="Tarjan算法求点的双连通分量"></a>Tarjan算法求点的双连通分量</h3><ul>
<li>时间戳(timestamp)，dfn[N], low[N], 和有向图的强连通分量作用相同</li>
<li>如何找到割点？若，对于 x - y，在 low[y] &gt;= dfn[x] (最多只能走到父节点) 的情况下：<ul>
<li>如果 x 不是根节点，那么 x 必定是一个割点</li>
<li>如果 x 是根节点，至少有两个子节点，那么 x 必定是一个割点</li>
</ul>
</li>
<li>如何求点的双连通分量？<ul>
<li>stack实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特判孤立点</span></span><br><span class="line"><span class="keyword">if</span> (u == 孤立点)</span><br><span class="line">&#123;</span><br><span class="line">  cnt ++ ;</span><br><span class="line">  此点单独为一个点的双连通分量；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dfn[x] &lt;= low[y])</span><br><span class="line">&#123;</span><br><span class="line">  cnt ++ ;</span><br><span class="line">  <span class="keyword">if</span> (x != 根节点 || cnt &gt; <span class="number">1</span>) x 是割点；</span><br><span class="line">  将栈中元素弹出，直至弹出 y 为止。</span><br><span class="line">  且 x 也属于此点的双连通分量。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>证明为什么将 x 加入 y 的双连通分量中：<ul>
<li>若 dfn[x] &lt;= low[y] 可以取到 = ，则 x 在此双连通分量是无可厚非的(必然的，正确的)</li>
<li>若 dfn[x] &lt; low[y] ，则 缩点后 x - y 只有一条边相连，两点一边本身就是一个点双连通分量，所以将 x 加入此双连通分量也是正确的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/1185/">1183. 电力</a></p>
<p><strong>题意：</strong>删除一个点，可以形成的最多的连通块的个数为多少？</p>
<p><strong>思路：</strong>求割点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> root, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(low[u] &gt;= dfn[u]) cnt ++; <span class="comment">// 无法上去, 删去则多一个连通块</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(u != root) cnt ++; <span class="comment">// 不是根节点，加上u的父节点的连通块( + 1 )</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">        idx = timestamp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (root = <span class="number">0</span>; root &lt; n; root ++ )</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cnt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题：</strong><a href="https://www.acwing.com/problem/content/398/">396. 矿场搭建</a></p>
<p><strong>题意；</strong>给定一个无向图，问最少在几个点上设置出口，可以使得不管其他哪个点坍塌，其余所有点都可以与某个出口相连；</p>
<p><strong>结论1：</strong>：</p>
<ul>
<li>出口数量 &gt;= 2</li>
<li>分别看每个连通块：<ul>
<li>(v-DCC 度数为0) 若 图中无割点(无论删除哪个点，剩余部分一定为连通的)：若 cnt 为图中点的个数， ans == C(2, cnt) == cnt * (cnt - 1) / 2</li>
<li>若 图中有割点：则需要缩点！<ul>
<li>每个割点单独作为一个点</li>
<li>从每个 v-DCC 向其所包含的每个割点连一条边</li>
</ul>
</li>
<li>v-DCC 度数为 1 ：需要在该分量内部(非割点)放一个出口</li>
<li>v-DCC 度数 &gt; 1 ：无需设置出口</li>
</ul>
</li>
</ul>
<p><strong>证明1：</strong></p>
<ul>
<li>缩点过，如果割点 坍塌，已知度数为 1 的点是叶子节点，则每一颗子树至少能被自己的叶子节点所救</li>
<li>如果度数为 1 的 v-DCC 中的某个点坍塌，可以通过割点走向另一个子树的叶子节点，从而逃脱</li>
<li>如果度数为 2 的 v-DCC 中的某个点坍塌，可以通过走到任意的一个割点从而走到子树的叶子节点，从而逃脱</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">int</span> dcc_cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判孤立点，也是点的双连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(u == root &amp;&amp; h[u] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc_cnt ++;</span><br><span class="line">        dcc[dcc_cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] &lt;= low[j])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++; <span class="comment">// 计算子树</span></span><br><span class="line">                <span class="keyword">if</span>(u != root || cnt &gt; <span class="number">1</span>) cut[u] = <span class="literal">true</span>;</span><br><span class="line">                ++ dcc_cnt;</span><br><span class="line">                <span class="type">int</span> y;</span><br><span class="line">                <span class="keyword">do</span> &#123;  </span><br><span class="line">                    y = stk[top -- ];</span><br><span class="line">                    dcc[dcc_cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">                &#125; <span class="keyword">while</span>(y != j); <span class="comment">// 加到 j 即可，不可加到 u ，可能有其他子树</span></span><br><span class="line">                dcc[dcc_cnt].<span class="built_in">push_back</span>(u); <span class="comment">// 最后补加一个割点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ ) dcc[i].<span class="built_in">clear</span>();</span><br><span class="line">        idx = n = timestamp = top = dcc_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">        <span class="built_in">memset</span>(cut, <span class="number">0</span>, <span class="keyword">sizeof</span> cut);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            n = <span class="built_in">max</span>(n, a), n = <span class="built_in">max</span>(n, b);</span><br><span class="line">            <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (root = <span class="number">1</span>; root &lt;= n; root ++ )</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        ULL num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dcc[i].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                <span class="keyword">if</span>(cut[dcc[i][j]])</span><br><span class="line">                    cnt ++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dcc[i].<span class="built_in">size</span>() &gt; <span class="number">1</span>) res += <span class="number">2</span>, num *= dcc[i].<span class="built_in">size</span>() * (dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>) res ++, num *= dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %llu\n&quot;</span>, ++ T, res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路求方案数</title>
    <url>/posts/1e2a4971/</url>
    <content><![CDATA[<h1 id="最短路求方案数"><a href="#最短路求方案数" class="headerlink" title="最短路求方案数"></a>最短路求方案数</h1><h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><ul>
<li>首先引入拓扑序的概念：计算当前状态时，当前状态所依赖的状态都已经计算出来了</li>
<li>类似DP，先求出全局最小值，再分别求出每个子集中等于全局最小值的元素数量，和最短路的唯一区别是，DP是在拓扑图中做最短路，但普通的最短路中可能存在环</li>
<li>若将最短路的模型转化为拓扑图，则可以用类似DP的方式处理求方案数的问题</li>
<li>其次引入最短路树（最短路拓扑图）<ul>
<li>概念：记录每个点是由哪个点更新来的，即若 <code>dist[j] = dist[t] + w[i] (t -&gt; j)</code>，j 可由 t 更新而来。</li>
<li>如果没有任何限制，则可能存在权值为0的环，可以在此环上转无限次，则最短路径的方案数为 INF，相当于无解了，求不出确切的树。</li>
<li>所以，如果想要求最短路的方案数，则图中不能存在权值为0的环，依照上述方案记录路径，即可形成拓扑图，简单地说，将可以求最短路时可以被利用的边保存（可更新最短路径上的点的边保存），其余边去掉。</li>
</ul>
</li>
</ul>
<h2 id="分析算法："><a href="#分析算法：" class="headerlink" title="分析算法："></a>分析算法：</h2><p>求最短路的算法系列：</p>
<p>热知识：判断是否满足拓扑序，此点不能更新之前已更新的点，反之则形成环，非拓扑序</p>
<ul>
<li>BFS系列（bfs）<ul>
<li>一层一层扩展，保证每个点只入队一次，且只出队一次，满足拓扑序</li>
</ul>
</li>
<li>Dijkstra系列（朴素dijkstra，堆优化dijkstra，双端队列广搜）<ul>
<li>每个点只作为最小值出队一次，之前出现的点的距离一定小于等于该点的距离，所以此点一定不会更新之前的点，满足拓扑序</li>
</ul>
</li>
<li>Bellman-ford系列（Bellman-ford，spfa）<ul>
<li>按照边更新，一个点出队都无法确定其为最小值，每个点可能入队多次，本身不具备拓扑序，若使用则需先用spfa算法预处理出来最短路径，建立最短路径树，然后在最短路径树上跑bfs等算法。</li>
</ul>
</li>
</ul>
<p>总结：bfs系列和dijkstra系列算法可以直接做，spfa比较麻烦需要预处理。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>, cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[ ++ tt ] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + <span class="number">1</span>)</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>方案数</category>
      </categories>
      <tags>
        <tag>方案数</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先(LCA问题)</title>
    <url>/posts/eaed4358/</url>
    <content><![CDATA[<h1 id="最近公共祖先-LCA问题"><a href="#最近公共祖先-LCA问题" class="headerlink" title="最近公共祖先(LCA问题)"></a>最近公共祖先(LCA问题)</h1><p>板子题：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/description/1174/">1172.祖孙询问</a></p>
<p>次小生成树应用：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/1173/">1171. 距离</a></p>
<p>树上差分应用：</p>
<p>例题：<a href="https://www.acwing.com/problem/content/description/354/">352. 闇の連鎖</a></p>
<p>三种方法如下：第二和第三种更实用一些</p>
<h2 id="法一：向上标记法"><a href="#法一：向上标记法" class="headerlink" title="法一：向上标记法"></a>法一：向上标记法</h2><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>每次查询：最坏情况 O(n)</li>
</ul>
<h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><ul>
<li>x 向上走到根节点，并标记所有经过的节点</li>
<li>y 向上走到根节点，当第一次遇到已经标记的节点时，就找到了 LCA(x, y)。</li>
</ul>
<h2 id="法二：树上倍增法"><a href="#法二：树上倍增法" class="headerlink" title="法二：树上倍增法"></a>法二：树上倍增法</h2><h3 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>预处理：O(nlogn)</li>
<li>每次查询：O(logn)</li>
</ul>
<h3 id="算法实现：-1"><a href="#算法实现：-1" class="headerlink" title="算法实现："></a>算法实现：</h3><ul>
<li>预处理：<ul>
<li>预处理数组 fa[i][j] ：表示从 i 开始，向上走 2^j 所能走到的节点。0 &lt;= j &lt;= logn。<ul>
<li>如何预处理：dfs 或 bfs 都可以</li>
<li>若fa[i][j]的节点不存在，则令 <code>fa[i][j] == 0</code>。</li>
<li>当 <code>j == 0</code>时，fa[i][j] = i 的父节点</li>
<li>当 <code>j &gt; 0</code>时，fa[i][j] = fa[fa[i][j - 1]][j - 1]，即、先跳到2^(j-1) 步，再跳 2^(j-1) 步</li>
</ul>
</li>
<li>预处理数组 depth[i]：表示深度，或层数，规定根节点的深度为 1，子节点的深度为父节点深度 +1</li>
</ul>
</li>
<li>具体步骤如下：基于倍增的思想<ul>
<li>先将两个点跳到同一层，</li>
<li>让两个点同时向上跳，一直跳都他们的最近公共祖先的下一层(因为，当二者相等时无法判断是否为最近的公共祖先，所以跳到最近公共祖先的下一层)</li>
</ul>
</li>
<li>哨兵：depth[0] = 0。如果从 i 开始跳 2^j 步会跳过根节点，那么 fa[i][j] = 0，此时depth[fa[i][j]] = 0，哨兵生效，停止跳跃。<ul>
<li>具体作用如下：</li>
<li>保证 lca 两点跳到同一层时，越界的深度小于任何树中节点的深度，从而停止此次跳跃；</li>
<li>保证 lca 查找公共祖先时，越界的二者的父节点相同，都是0，从而停止此次跳跃。</li>
</ul>
</li>
</ul>
<h3 id="具体板子如下："><a href="#具体板子如下：" class="headerlink" title="具体板子如下："></a>具体板子如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>, K = <span class="built_in">log2</span>(N); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][K + <span class="number">1</span>]; <span class="comment">// 需要用 1~K 层, 开到 K + 1 保证不越界</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求每个点的深度 depth[i];</span></span><br><span class="line"><span class="comment">// f[i][j] 表示：从i点开始，向上走2^j步，(0 &lt;= j &lt;= logn);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哨兵：当f[i][j]为0时(即、i的向上走2^j步不存在时), depth[f[i][j]] = 0</span></span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点初始化</span></span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 向上走2^0步(1步)，为父节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递推处理fa[i][j], 有点st表的感觉</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 令 a 为较深的点</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 较深的点a 跳到和b的同一层</span></span><br><span class="line">    <span class="comment">// depth[0] = 0作用：</span></span><br><span class="line">    <span class="comment">// 保证 lca 两点跳到同一层时，越界的深度小于任何树中节点的深度，从而停止此次跳跃；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 若 a 和 b 为同一点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若父节点不同，则变为父节点，再次比较</span></span><br><span class="line">    <span class="comment">// depth[0] = 0作用：</span></span><br><span class="line">    <span class="comment">// 保证 lca 查找公共祖先时，越界的二者的父节点相同，都是0，从而停止此次跳跃。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三：Tarjan算法——离线求LCA"><a href="#法三：Tarjan算法——离线求LCA" class="headerlink" title="法三：Tarjan算法——离线求LCA"></a>法三：Tarjan算法——离线求LCA</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><blockquote>
<p>算法本质是，使用并查集对向上标记法的优化。离线算法，读入所有询问，统一计算，统一输出</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>O(n + m)</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li>在深度遍历时，将所有点分为三大类<ul>
<li>第一类点：已经遍历过，并且已经回溯过的点，标记为 2</li>
<li>第二类点：正在搜索的分支，标记为 1</li>
<li>第三类点：还未搜索到的点，标记为 0</li>
</ul>
</li>
<li>若求lca(x, y)，对于正在访问的节点 x ，即、x 的标记为 1。若 y 是已经遍历过且回溯过的节点，则 lca(x, y) 就是从 y 向上走到根，第一个遇见的标记为 1 的节点，其实就是向上标记法。</li>
<li>并查集优化：<ul>
<li>当一个节点获得标记 2 时，把它所在的集合合并到其父节点所在的集合中(合并时，其父节点一定为 1)</li>
<li>所有标记为 2 的节点，都有一个指针指向其祖宗节点。若 x 的标记为 1 ，y 的标记为 2，查询 y 的向上走的第一个标记为 1 的节点就是 y 的祖宗节点(一定标记为 1 )，此祖宗节点就是 lca(x, y)</li>
</ul>
</li>
</ul>
<h3 id="具体板子如下"><a href="#具体板子如下" class="headerlink" title="具体板子如下"></a>具体板子如下</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> res[M];</span><br><span class="line">vector&lt;PII&gt; query[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有点分为三类：</span></span><br><span class="line"><span class="comment">// 第一类. 已经遍历过且搜索过的点，标记为 2</span></span><br><span class="line"><span class="comment">// 第二类. 正在搜索的分支，标记为 1</span></span><br><span class="line"><span class="comment">// 第三类. 还未搜索的点，标记为 0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历与此点的询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son = it.x, id = it.y;</span><br><span class="line">        <span class="keyword">if</span>(st[son] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(son);</span><br><span class="line">            res[id] = dist[u] + dist[son] - dist[anc] * <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四：dfs序列-RMQ算法（例如，st表）"><a href="#法四：dfs序列-RMQ算法（例如，st表）" class="headerlink" title="法四：dfs序列 + RMQ算法（例如，st表）"></a>法四：dfs序列 + RMQ算法（例如，st表）</h2><p>麻烦，且很不常用，了解即可</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><ul>
<li>dfs 遍历得 dfs 序列</li>
<li>若求 lca(x, y) ，则在 dfs 序列中，找任意的 x 和 y 求之间的最小值，此最小值就是 lca(x, y)</li>
</ul>
<h2 id="LCA-应用"><a href="#LCA-应用" class="headerlink" title="LCA 应用"></a>LCA 应用</h2><h3 id="LCA-树上倍增算法的应用-——-次小生成树"><a href="#LCA-树上倍增算法的应用-——-次小生成树" class="headerlink" title="LCA 树上倍增算法的应用 —— 次小生成树"></a>LCA 树上倍增算法的应用 —— 次小生成树</h3><blockquote>
<p>将朴素求树上两点路径之间的最值，化为倍增求最值，从而将时间复杂度由 O(n^2) 优化为 O(nlogn)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d1[N][<span class="number">17</span>], d2[N][<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            edge[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = -INF, d2[j][k] = -INF;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span>(d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(a != b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k];</span><br><span class="line">                b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dist1 = -INF, dist2 = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist1) <span class="keyword">return</span> w - dist1;</span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist2) <span class="keyword">return</span> w - dist2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA-应用-——-树上差分"><a href="#LCA-应用-——-树上差分" class="headerlink" title="LCA 应用 —— 树上差分"></a>LCA 应用 —— 树上差分</h3><blockquote>
<p>点的权值表示边的权值，其中 d[i]：表示差分节点 i 的权值(即、i 通向父节点的边的权值)；如果在 x, y的路径上 + c，则只需令 d[x] += c, d[y] += c, d[p] -= 2c;(其中 p = lca(x, y))。最终答案为d[res]：res 的所有子树的权值和</p>
</blockquote>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, K = <span class="built_in">log2</span>(N), INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][K + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[ ++ tt] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = K; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j, u);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) ans += m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>) ans += <span class="number">1</span>;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        d[a] ++, d[b] ++, d[p] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图的强连通分量(SCC)</title>
    <url>/posts/31194034/</url>
    <content><![CDATA[<h1 id="有向图的强连通分量-SCC"><a href="#有向图的强连通分量-SCC" class="headerlink" title="有向图的强连通分量(SCC)"></a>有向图的强连通分量(SCC)</h1><blockquote>
<p>强连通分量 : SCC, 有向无环图 : DAG</p>
</blockquote>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><ul>
<li>默认前提为有向图。</li>
<li>连通分量：对于分量中的任意两点 u, v, 必然存在可以从 u 走到 v, 且从 v 走到 u 。</li>
<li>强连通分量 (SCC)：极大连通分量，(无法加入任何点的连通分量)</li>
</ul>
<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ul>
<li>将任意一个有向图，通过 缩点 ，转化为有向无环图(拓扑图，DAG)</li>
<li>缩点：将所有连通分量缩成一个点</li>
<li>好处是求最短路或最长路时，可以递推来做，时间复杂度为 线性: O(n + m)</li>
</ul>
<h2 id="Tarjan算法理论基础："><a href="#Tarjan算法理论基础：" class="headerlink" title="Tarjan算法理论基础："></a>Tarjan算法理论基础：</h2><ul>
<li>按照 DFS 的顺序来求</li>
<li>把边分为四类<ul>
<li>树枝边 (x, y)：x 是 y 的父节点</li>
<li>前向边 (x, y)：x 是 y 的祖先节点 (x -&gt; y)</li>
<li>后向边 (x, y): 指向祖先节点的边 (y -&gt; x)</li>
<li>横叉边 (x, y): 指向之前搜过的边</li>
</ul>
</li>
<li>如何判断一个点是否在强连通分量中？<ul>
<li>情况1：存在<strong>后向边</strong>直接指向祖先节点</li>
<li>情况2：通过<strong>横叉边</strong>的<strong>后向边</strong>走到祖先节点</li>
</ul>
</li>
</ul>
<h2 id="Tarjan算法求强连通分量-SCC-："><a href="#Tarjan算法求强连通分量-SCC-：" class="headerlink" title="Tarjan算法求强连通分量(SCC)："></a>Tarjan算法求强连通分量(SCC)：</h2><ul>
<li>时间戳(timestamp)：根据深度优先遍历的顺序给每个点编号；<ul>
<li>对每个点定义两个遍历到 u 的时间戳，<ul>
<li>dfn[u]: 遍历到 u 的时间</li>
<li>low[u]: u 可以遍历到的最小的时间戳</li>
<li>若 u 是其所在强连通分量的最高点，则 dfn[u] == low[u]，可知，u 的强连通分量中不可以加入任何点了，如此就找到了 u 所在的强连通分量。</li>
</ul>
</li>
<li>各种边的性质如下：<ul>
<li>树枝边: dfn[y] &gt; dfn[x];</li>
<li>前向边: dfn[y] &gt; dfn[x];</li>
<li>后向边: dfn[y] &lt; dfn[x];</li>
<li>横向边: dfn[y] &lt; dfn[x];</li>
</ul>
</li>
</ul>
</li>
<li>如何实现：背过板子即可  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> din[N], dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j]) <span class="comment">// 没遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历过，且没在任何连通分量中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈中当前点之后的点为一个强连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];  <span class="comment">// 取出栈顶</span></span><br><span class="line">            in_stk[y] = <span class="literal">false</span>; <span class="comment">// 不在栈中</span></span><br><span class="line">            scc_id[y] = scc_cnt;   <span class="comment">// 标记为第scc_cnt号强连通分量 </span></span><br><span class="line">            scc_size[scc_cnt] ++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>缩点：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> k = e[j];</span><br><span class="line">      <span class="type">int</span> a = scc_id[i], b = scc_id[k];</span><br><span class="line">      <span class="keyword">if</span>( a != b) dout[a] ++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>连通分量编号递减的顺序一定为拓扑序，(不用多写一步拓扑排序)<ul>
<li>证明：类似 tarjan 算法类似如下的 dfs 求 拓扑排序</li>
<li>dfs 求拓扑排序，seq[N] 的逆序一定为拓扑排序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> u 的所有邻点：</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    seq &lt;- u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可证得，对于 seq 中每个点 u 其后继节点在 seq 中的位置一定在 u 的前面</li>
</ul>
</li>
</ul>
<p>例题：<a href="https://www.acwing.com/problem/content/1176/">1174. 受欢迎的牛</a></p>
<h2 id="代码板子如下："><a href="#代码板子如下：" class="headerlink" title="代码板子如下："></a>代码板子如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top -- ];</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line">            id[y] = scc_cnt;</span><br><span class="line">            scc_size[scc_cnt] ++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(y != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j];</span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k];</span><br><span class="line">            <span class="keyword">if</span>( a != b) dout[a] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">        &#123;</span><br><span class="line">            zeros ++;</span><br><span class="line">            sum += scc_size[i];</span><br><span class="line">            <span class="keyword">if</span>(zeros &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用结论及证明："><a href="#常用结论及证明：" class="headerlink" title="常用结论及证明："></a>常用结论及证明：</h2><blockquote>
<p>结论一：设一个图是非强连通分量，且 tarjan 算法得到的入度为0的点，即起点为P个，出度为0的点，即终点为Q个，把该图变为强连通分量(缩点缩成一个点)，最少需要加几条边？</p>
<p>答：最少需要新加 max(P, Q) 条边，特判掉若 P = Q == 1，则一个边都不用加。 </p>
</blockquote>
<h3 id="结论一证明："><a href="#结论一证明：" class="headerlink" title="结论一证明："></a>结论一证明：</h3><ul>
<li>分析可知 P &lt;= Q 的情况 和 P &gt;= Q 的情况类似，所以下面我们只证明 P &lt;= Q 的情况</li>
<li>当 P == 1 时，可知 P 可到达所有点，所以只需令 Q 个终点都与起点 P 连一条边，则所有路径的点都可以到达起点，即、所有点都可以到达所有点。答案为 Q ，满足 max(P, Q);</li>
<li>当 P &gt; 1 时，可知 Q &gt;= P &gt; 1，则前提 1：必然可以找到两个起点 P1, P2 和两个终点 Q1, Q2，使得 P1 -&gt; …… -&gt; Q1, P2 -&gt; …… -&gt; Q2，一定成立。<ul>
<li>简单证明前提 1：</li>
<li>反证法：如果找不到这样的两个点，则必然 Pi -&gt; …… -&gt; Q1 (解释，所有点都走向了 Q1 这个终点，但我们的终点不止 1 个，即、Q &gt; 1，则与已知条件矛盾)，所以必然有 一个 Pj -&gt; …… -&gt; Q2。</li>
</ul>
</li>
<li>从 Q1 连一条边向 P2 ，则 P —, Q — ，起点终点同时 -1。归纳为 加一条边 P, Q同时-1，若去掉 P - 1 次，则此时 P == 1，Q == Q - (P - 1)，此时由之前的 P == 1 的证明可知还需要再加 Q 条边，所以新加的边的总和为：P - 1 + Q - (P - 1) 即为 Q，满足 max(P, Q)</li>
<li>两种情况都成立，故结论成立，得证！</li>
</ul>
<p>例题：<a href="https://www.acwing.com/problem/content/1177/">1175. 最大半连通子图</a></p>
<blockquote>
<p>思路：缩点后找最长链(tarjan的强连通分量 + 背包问题求方案数)</p>
</blockquote>
<p>例题：<a href="https://www.acwing.com/problem/content/370/">368. 银河</a></p>
<blockquote>
<p>思路：强连通分量找正环 + 拓扑排序求最长路 </p>
</blockquote>
]]></content>
      <categories>
        <category>图论</category>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素 dijkstra 算法</title>
    <url>/posts/bc46f58a/</url>
    <content><![CDATA[<h1 id="朴素-Dijkstra-算法"><a href="#朴素-Dijkstra-算法" class="headerlink" title="朴素 Dijkstra 算法"></a>朴素 Dijkstra 算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>$O(n^2)$</li>
</ul>
<h2 id="算法应用情景："><a href="#算法应用情景：" class="headerlink" title="算法应用情景："></a>算法应用情景：</h2><ul>
<li>不含有负权边的图中</li>
</ul>
<h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><ul>
<li>初始化，将起点加入已更新的点中，并将起点的 <code>dist</code> 设为 0，其余点的 <code>dist</code> 为 INF，代表没更新</li>
<li>循环 <code>n - 1</code> 次，每次更新一个点，</li>
<li>用这个点更新其他点到起点的距离</li>
</ul>
<h2 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h2><p><img src="https://img-blog.csdnimg.cn/0921267586bb431fab5bc2e42a854077.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pm0X-aYjg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="朴素 $Dijkstra$ 算法"></p>
<h2 id="模板代码如下："><a href="#模板代码如下：" class="headerlink" title="模板代码如下："></a>模板代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 邻接矩阵，存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 先选中一个点，剩余 n - 1 个点，迭代 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"> </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h2><blockquote>
<p>$Dijkstra$ 算法严格规定一个点出队即为这个点的最短路，若一个点出队后，之后的点中有负权边，则之前的点应该被更新，但这个点已经出队，无法被更新，所以 $Dijkstra$ 系列算法都无法处理负权边的情况。</p>
</blockquote>
<h2 id="具体证明："><a href="#具体证明：" class="headerlink" title="具体证明："></a>具体证明：</h2><ul>
<li>如何证明最短路？仅需证明路径中的每一步都为当前的所有可行的道路中的最小值即可，每一步都最小，则所有步相加，必定可以使得结果最小，</li>
<li>$Dijkstra$ 算法正是如此，基于贪心的原理，每一次所走的路为当前可走的路中的最小值，所以可以增明最短路，</li>
<li>此外，还可以证明的是当一个点出队时，当前值即为从起点到该点的最短路，思路由数学归纳法可知，和证明终点为最短路类似，令该点为终点，可发现代码实现和原代码如出一辙，由此得证</li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>朴素 Dijkstra 算法</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/posts/5ff58a77/</url>
    <content><![CDATA[<h1 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h1><p>例题：<a href="!https://www.acwing.com/problem/content/1150/">1148. 秘密的牛奶运输</a></p>
<blockquote>
<p>定理：对于一张无向图，如果存在最小生成树和(严格)次小生成树，那么对于任何一棵最小生成树，都存在一棵(严格)次小生成树，使得着两棵树只有一条边不同</p>
</blockquote>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><ul>
<li>先求最小生成树，再枚举删去最小生成树中的边求解。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>O(mlogm + nm)</li>
</ul>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><ul>
<li>化零为整：把最小生成树与次小生成树得不同得一条边分为n-1类(1~n-1)</li>
<li>只需求出每一类得最小值，则一定可以求出次小生成树</li>
</ul>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><ul>
<li>求非严格次小生成树可以，但求严格次小生成树不太方便</li>
</ul>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>先求最小生成树，然后依次枚举非树边，将该边加入树中，同时从树中去掉一条边，使得最终得图仍然是一棵树。则一定可以求出次小生成树。</li>
</ul>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li>朴素算法 O(m + n^2 + mlogm))</li>
<li>lca 倍增优化 O(nlogn)</li>
</ul>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul>
<li>声明：<ul>
<li>设T为图G得一棵生成树，对于非树边a和树边b，插入边a，并删除边b的操作记为(+a,-b)。</li>
<li>如果T+a-b之后，仍然是一棵生成树，称(+a,-b)是T的一个可行交换。</li>
<li>由T进行一次可行变换所得到的新的生成树的集合称为T的邻集。</li>
</ul>
</li>
<li>定理：<ul>
<li>次小生成树一定再最小生成树的邻集中。</li>
</ul>
</li>
<li>证明如下：<ul>
<li>反证法：假设存在某一个图，次小生成树和最小生成树至少两条边不同。</li>
<li>先考虑非严格次小生成树：<ul>
<li>先最小生成树从小到大排序，枚举所有的最小生成树的边，枚举该边是否在次小生成树中，若不在，则将该边加上，形成环，去掉后面的边，权值小于等于之前的生成树，结果不会变坏，且次小生成树与最小生成树仍然由差异，则该操作成立，如此反复，直到次小生成树和最小生成树只剩一条边不同为止。</li>
</ul>
</li>
<li>再考虑严格次小生成树：<ul>
<li>类似上述操作，两边相等则不变(不用担心完全一样的问题，因为严格次小一定大于最小)，若当前枚举的最小生成树的边较小，则替换。如此可构造出只剩一条边不同的次小生成树</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="朴素代码如下；"><a href="#朴素代码如下；" class="headerlink" title="朴素代码如下；"></a>朴素代码如下；</h2><p>注意：在求严格次小生成树时，不能只预处理两点之间最大的树边，因为当最大树边和当前枚举的非树边长度相同时，就不能替换了，但此时却可以替换长度次大的树边。因此还需同时预处理出长度次大的树边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], w[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            edge[i].f = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> td1 = maxd1, td2 = maxd2;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; td1) td2 = td1, td1 = w[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i] &lt; td1 &amp;&amp; w[i] &gt; td2) td2 = w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(j, u, td1, td2, d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        p[i] = i;</span><br><span class="line">        </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist1[i], dist2[i]);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            LL t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(w &gt; dist1[a][b]) t = sum + w - dist1[a][b];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w &gt; dist2[a][b]) t = sum + w - dist2[a][b];</span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lca-倍增优化版代码如下："><a href="#lca-倍增优化版代码如下：" class="headerlink" title="lca 倍增优化版代码如下："></a>lca 倍增优化版代码如下：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d1[N][<span class="number">17</span>], d2[N][<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            edge[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = -INF, d2[j][k] = -INF;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span>(d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(a != b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k];</span><br><span class="line">                b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dist1 = -INF, dist2 = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist1) <span class="keyword">return</span> w - dist1;</span><br><span class="line">    <span class="keyword">if</span>(w &gt; dist2) <span class="keyword">return</span> w - dist2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此返回值不会被用到</span></span><br><span class="line">    <span class="comment">// 当 dist1 无法被用时，dist2 一定小于 w </span></span><br><span class="line">    <span class="comment">// 证明：当 w == dist1 时：dist2 &lt; dist1；当 w &lt; dist1 时，dist2 &lt; dist1</span></span><br><span class="line">    <span class="comment">// 所以 w &gt; dist2 时一定成立的</span></span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edge[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
        <category>次小生成树</category>
      </categories>
      <tags>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉回路和欧拉路径</title>
    <url>/posts/903ad369/</url>
    <content><![CDATA[<h1 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h1><p><strong>引入：</strong>哥尼斯堡七桥问题</p>
<p>欧拉路径 == 一笔画问题</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul>
<li>欧拉路径<ul>
<li>起点终点 度数为奇数</li>
<li>中间顶 度数为偶数</li>
</ul>
</li>
<li>对于无向图，所有边都是连通的<ul>
<li>存在欧拉路径的充分必要条件：度数(入读 + 出度)为奇数的点只能由0或2个。</li>
<li>存在欧拉回路的充分必要条件：度数为奇数的点为0个。</li>
</ul>
</li>
<li>对于有向图，所有边都是连通的<ul>
<li>存在欧拉路径的充分必要条件：所有点的出度均等于入度 或 除了两个点以外，其余所有点出度等于入度，剩余两个点 一个满足出度比入度多1（起点），一个满足入度比出度多1（终点）</li>
<li>存在欧拉回路的充分必要条件：所有点的出度均等于入度</li>
</ul>
</li>
</ul>
<h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><ul>
<li>左 -&gt; 右：已证明，右边本就是由左边推来的。</li>
<li>左 &lt;- 右：构造一种方案合法，即可证明<ul>
<li>直接 DFS ，遇到回路则进去转一圈出来，则一定可以走到终点，最终路径为一条线挂着许多环。 </li>
</ul>
</li>
</ul>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><p>seq数组保存路径，最终的路径是 seq 的逆序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> 从 u 出发的所有边</span><br><span class="line">    <span class="built_in">dfs</span>() <span class="comment">// 扩展</span></span><br><span class="line">seq &lt;- u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉回路的 dfs 遍历时，用边判重(used数组)，会导致时间复杂度较高(平方级别)，优化为 遍历一条边，删去一条边，即可保证为线性的复杂度。</p>
<p><strong>例题：</strong> <a href="https://www.acwing.com/problem/content/1126/">1124. 骑马修栅栏</a></p>
<p><strong>思路：</strong>欧拉回路找最小字典序即可</p>
<blockquote>
<p>如何保证最小字典序，从最小的点开始走。从最小的点开始走，则会最后回溯这个点，如此逆序即为字典序最小的序列。</p>
</blockquote>
<p><strong>代码如下：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">2100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">500</span>, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> ans[M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(g[u][i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] --, g[i][u] --;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    ans[ ++ cnt] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a][b] ++, g[b][a] ++;</span><br><span class="line">        d[a] ++, d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!d[start]) start ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(d[i] % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">dfs</span>(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; i -- )</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>图论</category>
        <category>欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉回路</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>算法杂项</title>
    <url>/posts/66485649/</url>
    <content><![CDATA[<h1 id="算法杂项"><a href="#算法杂项" class="headerlink" title="算法杂项"></a>算法杂项</h1><h2 id="数论部分"><a href="#数论部分" class="headerlink" title="数论部分"></a>数论部分</h2><h3 id="两个数互质则不能由-p-q-凑出来的最大的数为-p-1-q-1-1"><a href="#两个数互质则不能由-p-q-凑出来的最大的数为-p-1-q-1-1" class="headerlink" title="两个数互质则不能由 p, q 凑出来的最大的数为 (p - 1) * (q - 1) - 1;"></a>两个数互质则不能由 p, q 凑出来的最大的数为 <code>(p - 1) * (q - 1) - 1;</code></h3><h2 id="平面直角坐标系部分"><a href="#平面直角坐标系部分" class="headerlink" title="平面直角坐标系部分"></a>平面直角坐标系部分</h2><h3 id="皮克定理："><a href="#皮克定理：" class="headerlink" title="皮克定理："></a>皮克定理：</h3><p><strong>定理：</strong> 皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式，该公式可以表示为 <code>S = a + b/2 - 1</code>，其中 a 表示多边形内部的点数，b 表示多边形落在格点边界上的点数，S 表示多边形的面积。</p>
<blockquote>
<p><strong>结论：</strong> s(面积) = a(中间的点) + b(边上的点) / 2 - 1</p>
</blockquote>
<h3 id="两点-x1-y1-x2-y2-的连线上的整点数-："><a href="#两点-x1-y1-x2-y2-的连线上的整点数-：" class="headerlink" title="两点(x1, y1)(x2, y2)的连线上的整点数 ："></a>两点(x1, y1)(x2, y2)的连线上的整点数 ：</h3><blockquote>
<p><strong>结论：</strong> <code>abs(gcd(x1 - x2, y1 - y2))</code></p>
</blockquote>
<p><strong>证明</strong> </p>
<ul>
<li>将该直线其中一点移动到原点(0, 0)，另一点为(a, b)，则该直线斜率为 b’ / a’ (约分过)，则该支线上的所有点一定为 <code>k * (b&#39; / a&#39;)</code>，k 可取 1, 2, 3, …… , gcd(a, b)。化为原坐标即为 <code>gcd(x1 - x2, y1 - y2)</code> , 因为 gcd 函数可能得负数，所以取 绝对值 abs()</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-期末复习</title>
    <url>/posts/b9598422/</url>
    <content><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><blockquote>
<p>从多方面比较电路交换、报文交换、分组交换的优缺点；</p>
</blockquote>
<ol>
<li>电路交换：需要建立连接，端对端通信质量因约定了通信资源获得可靠保障，对连续传送大量数据效率高。</li>
<li>报文交换：无须预约传输带宽，动态逐段利用传输带宽，对突发式数据通信效率高，通信迅速。</li>
<li>分组交换：具有报文交换之高效、迅速的要点，且各分组小，路由灵活，网络生存性能好。</li>
</ol>
<blockquote>
<p>计算机网络的分类；</p>
</blockquote>
<p>按照网络的作用范围进行分类: </p>
<ol>
<li>广域网 WAN </li>
<li>城域网 MAN </li>
<li>局域网 LAN</li>
<li>个人区域网 PAN</li>
</ol>
<p>按照网络地使用者进行分类:</p>
<ol>
<li>公用网 (public network)</li>
<li>专用网 (private network)</li>
</ol>
<p>用来把用户接入互联网的网络: </p>
<ol>
<li>接入网 AN (access network)</li>
</ol>
<blockquote>
<p>计算机网络常用的性能指标有哪些，其中时延由哪几部分组成；</p>
</blockquote>
<ol>
<li>速率：速率是指连接在计算机网络上的主机在数字信道上传送数据的速率。是计算机网络中最重要的一个性能指标。当数据率较高时，就常常在 bit/s 的前面加上一个字母。速率往往是指额定速率或标称速率，并非网络上实际上运行的速率。</li>
<li>带宽：本意是指某个信号具有的频带宽度。在计算机网络中，带宽指网络的通信线路传送数据的能力（单位时间内从网络中的某一个点到另外一个点所能通过的最高数据率，带宽的单位为 bit/s）。</li>
<li>吞吐量：吞吐量表示单位时间内通过某个网络（通信线路、接口）的实际的数据量。吞吐量受制于带宽或者网络的额定速率。</li>
<li>时延：时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络 (或链路) 的一端传送到另一端所需的时间。有时也称为延迟或迟延。 时延由发送时延、传播时延、处理时延、排队时延组成。</li>
<li>时延带宽积：时延带宽积指传播时延带宽，表示一条链路上传播的所有比特（以比特为单位）。如下图，将管道的长度看做链路的传播时延，管道的截面积是链路的带宽，则时延带宽积代表管道的体积，即表示这样的链路可以容纳多少个比特 ，不难看出，管道中的比特数表示从发送端发出的但未到达接收端的比特（因此链路的时延带宽积又称为以比特为单位的链路长度）。 对于一条正在传送数据的链路，只有在代表链路的管道都充满比特时，链路才得到了充分的利用。</li>
<li>往返时间 RTT：往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</li>
<li>利用率：信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。信道利用率或网络利用率过高就会产生非常大的时延, 并非越高越好。</li>
</ol>
<blockquote>
<p>论述具有五层协议的网络体系结构的要点，包括各层的主要功能。</p>
</blockquote>
<ol>
<li>物理层: 主要实现接口的物理结构特性、电气特性和功能特性进行定义，<strong>用于连接传输介质</strong>，使高层不用关心介质的问题；传输单位是: <strong>比特(Bit)</strong></li>
<li>数据链路层: 主要实现<strong>相邻节点</strong>的通信问题，使用MAC地址，传输单元是<strong>帧</strong>；</li>
<li>网络层: 主要实现在<strong>不同的网络</strong>之间进行数据传输，进行路由，实现IP地址封装；传输单位: <strong>**分组</strong></li>
<li>运输层: 实现<strong>两台主机进程之间的通信</strong>，使用端口地址；传输单位: <strong>报文段, 用户数据报</strong></li>
<li>应用层: <strong>直接给用户提供服务</strong>，应用层协议的丰富程度决定网络提供给用户的功能。传输单位: <strong>报文</strong></li>
</ol>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><p>设备:<br>物理层 : 中继器, 集线器<br>数据链路层 : 网桥, 交换机<br>网络层 : 路由器   </p>
<blockquote>
<p>物理层的接口有哪几方面特性，各包含些什么内容；</p>
</blockquote>
<ol>
<li>机械特性: 指明接口所用接线器的形状和尺寸, 引脚数目和排列,固定和锁定装置等</li>
<li>电气特性: 指明在接口电缆的各条线上出现的电压的范围</li>
<li>功能特性: 指明在某条线上出现的某个点平的电压的意义</li>
<li>过程特性: 指明对于不同功能的各种可能事物的出现顺序</li>
</ol>
<blockquote>
<p>常用的传输媒体有哪些，各有什么特点；</p>
</blockquote>
<ol>
<li>双绞线: 双绞线是一种常见的传输媒体，通常由多对绝缘的铜线组成。它分为无屏蔽双绞线（UTP）和屏蔽双绞线（STP）两种类型。双绞线<strong>价格低廉、易于安装和维护</strong>，但相对于其他传输媒体，它的<strong>传输距离较短</strong>且<strong>对电磁干扰敏感</strong>。</li>
<li>同轴电缆: 同轴电缆由一个中心导体、绝缘层、屏蔽层和外部绝缘层组成。它具有<strong>较高的带宽和传输距离，对电磁干扰的抗性较强</strong>。同轴电缆常用于有线电视、局域网和宽带接入等应用。</li>
<li>光缆(光纤): 光纤是一种使用光信号传输数据的传输媒体。它由一个或多个纤维芯和包围纤维芯的折射材料组成。光纤具有<strong>高带宽、低损耗、抗电磁干扰</strong>的特点，可以<strong>传输大量数据和远距离通信</strong>。然而，光纤的安装和维护成本较高。</li>
<li>无线传输: 无线传输通过无线电波或红外线等无线信号进行数据传输。无线传输具有<strong>灵活性</strong>和易于部署的优势，适用于移动通信、无线局域网和蓝牙等应用。然而，无线传输受到<strong>距离限制、信号干扰和安全性</strong>等问题的影响。</li>
</ol>
<blockquote>
<p>为什么使用信道复用技术</p>
</blockquote>
<ul>
<li>为了提高通信系统的效率和容量。通过将多个信号或数据流合并到一个物理信道上进行传输，可以充分利用有限的频谱资源，并使多个用户或设备同时进行通信。</li>
<li>背 : 多个计算机共享信道资源, 提高信道利用率,  </li>
</ul>
<blockquote>
<p>常用的信道复用技术有哪些；</p>
</blockquote>
<ol>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ol>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><blockquote>
<p>数据链路层解决的三个基本问题是什么，为什么都必须加以解决；</p>
</blockquote>
<ol>
<li>封装成帧: 在一段数据的前后分别添加首部和尾部, 这样就构成了一个帧, 帧定界。每个帧通常由帧起始标记、帧数据和帧结束标记组成。封装成帧的目的是使接收方能够识别和区分不同的帧，确保数据的准确传输和正确的重组。</li>
<li>透明传输: 数据链路层应该能够在传输过程中无差错地传输任何比特组合，包括数据帧中的控制字符。这是因为在数据链路层传输过程中，某些比特组合可能与控制字符相同，如果没有透明传输，这些组合可能会被错误地解释为控制字符，导致数据传输错误。</li>
<li>差错检测: 差错检测是数据链路层用来检测传输过程中引入的比特错误。常用的差错检测方法包括循环冗余校验（CRC）和奇偶校验。通过附加冗余的校验位，接收方能够检测出接收到的帧是否存在比特错误，以便进行差错恢复或重新传输。</li>
<li>为什么必须加以解决: <ol>
<li>封装成帧确保数据能够被正确地划分为帧，使接收方能够正确地识别和处理数据。</li>
<li>透明传输保证数据链路层在传输过程中不会错误地解释控制字符，从而确保数据的准确传输。</li>
<li>差错检测能够及时发现传输过程中引入的比特错误，使得接收方能够检测并纠正这些错误，确保数据的可靠性。</li>
</ol>
</li>
</ol>
<blockquote>
<p>利用CRC(循环冗余检验)检验计算余数，或者判断传输过程中是否出现比特差错；</p>
</blockquote>
<ul>
<li>计算机网络(第五版) P112, 3-07, </li>
<li>生成多项式</li>
<li>帧检验序列FCS</li>
<li>步骤: </li>
</ul>
<blockquote>
<p>CSMA/CD协议的要点是什么；</p>
</blockquote>
<ol>
<li>载波监听(CS): 在发送数据之前，节点会侦听物理介质上是否有其他节点正在传输数据。如果检测到有其他节点正在发送数据，节点将等待一段时间，直到介质空闲，然后才开始发送数据。</li>
<li>多点接入(MA): 多个节点共享同一条物理介质进行数据传输。每个节点都具有相同的权利和机会发送数据。</li>
<li>碰撞检测(CD): 如果两个或多个节点在同一时间发送数据，会发生冲突。节点会继续发送数据，并同时侦听物理介质上的信号。如果节点检测到冲突，它会立即停止发送，并发送一个干扰信号来通知其他节点发生了冲突。</li>
<li>退避与重传: 当发生冲突时，节点会执行退避操作，即随机选择一个时间延迟后再次尝试发送数据。每次发生冲突后，退避时间会加倍，以减少冲突的概率。节点会在一定的重传次数后放弃发送数据。</li>
<li>最小帧传输时间: 为了确保数据传输的完整性，节点发送的数据帧的最小长度必须满足一定的要求（如最小帧长度为64字节）。这是为了确保所有节点能够检测到冲突，并在发生冲突时及时停止发送数据。</li>
</ol>
<p><img src="/posts/b9598422/CSMA_CD.png" alt="CSMA/CD"></p>
<p>过程: </p>
<ol>
<li>发送数据前先监听信道 </li>
<li>若信道不忙则发送数据, 同时持续冲突检测</li>
<li>若发送数据时检测到冲突, 则停止发送, 等待随机长的时间</li>
<li>若无冲突则发送成功</li>
</ol>
<blockquote>
<p>利用交换机的自学习算法，更新交换表，判断帧转发接口。</p>
</blockquote>
<ul>
<li>教材 P114, 3-33</li>
<li>例题 :<br><img src="/posts/b9598422/交换机自学习算法.png" alt="交换机自学习算法"></li>
</ul>
<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><blockquote>
<p>简述集线器、交换机、路由器的功能和区别；</p>
</blockquote>
<ol>
<li>集线器工作在物理层: 将多个物理设备连接到同一个局域网, 提高数据传输速度</li>
<li>交换机工作在数据链路层: 识别已连接的物理设备, 并将这些地址存储在路由表中, 减少网络上不必要的流量</li>
<li>路由器工作在网络层: 连接不同网络, 促使不同网络的主机完成通信</li>
</ol>
<blockquote>
<p>给定点分十进制（二进制）表示的IP地址，将其转换为二进制（十进制）表示，并判断IP地址的类别；</p>
</blockquote>
<ul>
<li>A类: 0+网络号(8位, 1~127) + 主机号(24位) </li>
<li>B类: 10+网络号(16位, 128~191) + 主机号(16位)</li>
<li>C类: 110+网络号(24位, 192~223) + 主机号(8位)</li>
<li>D类: 1110+多播地址</li>
<li>E类: 1111+保留位今后使用 </li>
</ul>
<blockquote>
<p>给定IP地址的类别，判断其网络号和主机号；</p>
</blockquote>
<ol>
<li>类别A地址：<ul>
<li>网络号：第一个字节（8位）为网络号，剩余的三个字节（24位）为主机号。</li>
<li>范围：1.0.0.0 到 126.0.0.0（其中1.0.0.0为保留地址，126.0.0.0为广播地址, 不算主机号）。</li>
<li>可用网络数: 2^7-2(全0, 和 127.环回地址)</li>
</ul>
</li>
<li>类别B地址：<ul>
<li>网络号：前两个字节（16位）为网络号，剩余的两个字节（16位）为主机号。</li>
<li>范围：128.0.0.0 到 191.255.0.0（其中128.0.0.0为保留地址，191.255.0.0为广播地址, 不算主机号）。</li>
<li>可用网络数: 2^14-1</li>
</ul>
</li>
<li>类别C地址：<ul>
<li>网络号：前三个字节（24位）为网络号，剩余的一个字节（8位）为主机号。</li>
<li>范围：192.0.0.0 到 223.255.255.0（其中192.0.0.0为保留地址，223.255.255.0为广播地址, 不算主机号）。</li>
<li>可用网络数: 2^21-1</li>
</ul>
</li>
<li>类别D地址（多播地址）和类别E地址（保留地址）不进行网络号和主机号的划分。</li>
</ol>
<blockquote>
<p>给定IP地址的类别，以及子网掩码，计算每一个子网上的最大主机数；</p>
</blockquote>
<ul>
<li>要计算每个子网上的最大主机数，需要知道IP地址的类别以及子网掩码。根据子网掩码的位数，可以确定网络号和主机号的划分方式。以下是不同类别和子网掩码的情况下计算每个子网上的最大主机数的方法：</li>
</ul>
<ol>
<li>类别A地址：<ul>
<li>子网掩码为 255.0.0.0 或 /8，其中网络号占用8位。</li>
<li>最大主机数 = 2^(32-8) - 2，其中32为IP地址的总位数，减去2是因为网络地址和广播地址不能用于主机。</li>
</ul>
</li>
<li>类别B地址：<ul>
<li>子网掩码为 255.255.0.0 或 /16，其中网络号占用16位。</li>
<li>最大主机数 = 2^(32-16) - 2，其中32为IP地址的总位数，减去2是因为网络地址和广播地址不能用于主机。</li>
</ul>
</li>
<li>类别C地址：<ul>
<li>子网掩码为 255.255.255.0 或 /24，其中网络号占用24位。</li>
<li>最大主机数 = 2^(32-24) - 2，其中32为IP地址的总位数，减去2是因为网络地址和广播地址不能用于主机。</li>
</ul>
</li>
</ol>
<ul>
<li>请注意，最大主机数是指每个子网上可用于分配给实际主机的IP地址数量，其中减去2是因为网络地址和广播地址在每个子网中都是保留的。</li>
</ul>
<blockquote>
<p>ARP协议 (地址解析协议) 的工作原理；</p>
</blockquote>
<ul>
<li>作用: 根据IP地址获取MAC地址的一个协议。</li>
<li>方法: 在主机的ARP高速缓存中存放一个从IP地址到MAC地址的映射表, 并且这个映射表还经常动态更新(新增或超时删除)</li>
<li>原理: 主机向自己所在的网络广播一个ARP请求, 该请求包含目标机器的网络地址, 此网络上的其他机器都将收到这个请求, 但只有被请求的目标机器会回应一个ARP请求, 其中包含一个自己的 MAC 地址</li>
</ul>
<blockquote>
<p>已知IP地址和子网掩码，计算网络地址；</p>
</blockquote>
<ul>
<li>把二进制的<strong>IP</strong>地址何地址掩码进行<strong>按位AND</strong>运算, 可得出网络地址</li>
</ul>
<blockquote>
<p>利用路由表信息，讨论分组转发的过程；</p>
</blockquote>
<ol>
<li>提取IP数据报告首部中的目的IP地址</li>
<li>判断目的IP地址所在的网络是否与本路由器直接相连。如果是，就直接交付给目的网络，如果不是执行3）</li>
<li>检查路由器表中是否有目的IP地址的特定主机路由。如果有，按特定主机路由转发：如果没有，执行4）</li>
<li>逐条检查路由表。若找到匹配路由，则按照路由表进行转发：若所有路由均不匹配，则执行5）</li>
<li>若路由表中设置有默认路由，则按照默认路由表转发：否则，执行6）</li>
<li>向源主机报错。</li>
</ol>
<blockquote>
<p>给定一个路由表，收到一个分组，计算该分组的下一跳；</p>
</blockquote>
<ul>
<li>要计算一个分组的下一跳，需要根据路由表中的信息进行匹配。下面是计算分组下一跳的一般过程：</li>
<li>首先，检查分组的目标IP地址。</li>
</ul>
<ol>
<li>逐个检查路由表中的条目，将目标IP地址与每个条目中的目标网络地址和子网掩码进行匹配。</li>
<li>如果目标IP地址与某个条目中的目标网络地址和子网掩码匹配，那么该条目即为最佳匹配。</li>
<li>最佳匹配的条目中包含下一跳的IP地址。这个IP地址就是分组的下一跳。</li>
<li>将分组发送到下一跳的IP地址，以便继续转发到目标主机。</li>
</ol>
<ul>
<li>需要注意的是，路由表中的条目按照最长前缀匹配的原则进行匹配。即如果有多个条目与目标IP地址匹配，应选择最具体（最长前缀）的条目作为最佳匹配。</li>
<li>最长前缀匹配的解释: 网络前缀越长, 其地址块就越小, 因而路由就越具体</li>
</ul>
<blockquote>
<p>给定一个地址块，计算地址块中最小地址和最大地址，地址掩码，以及地址块中有多少个地址；</p>
</blockquote>
<ul>
<li>要计算地址块中的最小地址和最大地址，以及地址掩码和地址块中的地址数量，需要知道地址块的起始IP地址和地址块的前缀长度（或子网掩码）。下面是计算的步骤：</li>
</ul>
<ol>
<li>确定地址块的起始IP地址和前缀长度（或子网掩码）。</li>
<li>根据前缀长度计算出子网掩码。子网掩码是一个32位的二进制数，前面连续的1表示网络部分，后面连续的0表示主机部分。</li>
<li>将起始IP地址和子网掩码进行逻辑与操作，得到地址块的网络地址。逻辑与操作是将两个二进制数的对应位进行与运算，得到的结果即为网络地址。</li>
<li>最小地址即为地址块的网络地址。</li>
<li>计算地址块的主机数量。主机数量等于2的(32-前缀长度)次方减去2，其中减去2是因为网络地址和广播地址不能用于主机。</li>
<li>最大地址即为地址块的网络地址加上主机数量减1。</li>
</ol>
<p>举例: </p>
<ul>
<li>假设有一个地址块，起始IP地址为192.168.0.0，前缀长度为24。</li>
<li>根据前缀长度计算子网掩码：255.255.255.0。</li>
<li>进行逻辑与操作：192.168.0.0 &amp; 255.255.255.0 = 192.168.0.0，得到网络地址。</li>
<li>最小地址为192.168.0.0。</li>
<li>主机数量为2的(32-24)次方减去2，即2^8-2=254。</li>
<li>最大地址为192.168.0.0 + 254 = 192.168.0.253。</li>
<li>因此，给定地址块的最小地址为192.168.0.0，最大地址为192.168.0.253，子网掩码为255.255.255.0，地址块中有254个地址。</li>
</ul>
<blockquote>
<p>利用RIP协议(内部网关协议, 基于距离向量)的工作原理，更新路由表。</p>
</blockquote>
<p>根据转发表(前缀匹配, 下一跳), 收到分组, 已知目的地址, 先看前缀匹配是否成立(按位与)? 如果多个成立, 则选择前缀较长的那个</p>
<ul>
<li>路由器收到相邻路由器(其地址为X)的一个 RIP 报文: </li>
</ul>
<ol>
<li>先修改此RIP报文中的所有项目, 把”下一跳”字段中的地址都改为X, 并把所有的”距离”字段的值+1</li>
<li>对修改后的RIP报文中的每一个项目, 重复以下步骤<ol>
<li>若项目中的目的网络不在路由表中, 则把该项目加入路由表中</li>
<li>若下一跳字段给出的路由器地址的同样的, 则把收到的项目替换为原路由表中项目</li>
<li>若收到的项目中的距离小于路由表中的距离, 则进行更新</li>
</ol>
</li>
<li>若3分钟还没有收到相邻路由器的更新路由表, 则把此相邻路由器记为不可达路由器, 将距离置为16(表示不可达)</li>
</ol>
<p>给你两个路由表, B C, 用C更新B<br>步骤: </p>
<ol>
<li>先把路由表C, 距离全部+1, 下一跳全部为C</li>
<li>根据C, 更新B中对应目的网络的距离和下一跳, 更新的依据在上面, (无则更新, 下一跳相同则更新, 当前距离小于原表距离则更新) </li>
<li>习题: <a href="https://www.bilibili.com/video/BV1M84y1n7To/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2c230dd0ea0ef62177baa1492c6409fe">计算机网络习题-RIP路由表更新</a></li>
</ol>
<h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><blockquote>
<p>论述TCP协议与UDP协议的区别；</p>
</blockquote>
<ul>
<li>UDP: <ol>
<li>传送数据之前不需要先建立连接</li>
<li>收到 UDP报 后, <strong>不需要给出任何确认</strong></li>
<li>不提供可靠交付, 但是一种最有效的工作方式</li>
</ol>
<ul>
<li>举例: 域名解析服务DNS, 路由选择RIP, 文件传输TFTP,  </li>
<li>背: 不可靠, 无连接, 时延小, 适用于小文件</li>
</ul>
</li>
<li>TCP:<ol>
<li>提供可靠的, 面向连接的运输服务</li>
<li>不提供广播或多播服务</li>
<li>开销较多</li>
</ol>
<ul>
<li>万维网(WWW)HTTP, 电子邮件SMTP, 文件传输FTP, </li>
<li>背: 可靠, 面向连接, 时延大, 适用于大文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么说UDP是面向报文的，而TCP是面向字节流的；</p>
</blockquote>
<ol>
<li>UDP(用户数据报协议)是面向报文的协议, 因为当应用程序向UDP发送数据时, UDP会将该数据封装成一个个的数据报, 每个数据报都包含了完整的数据和必要的控制信息。每个数据报都独立处理, 发送方和接收方之间没有建立逻辑连接, 也不会对数据包进行拆分或合并。</li>
<li>TCP(传输控制协议)则是面向字节流的协议, 当应用程序向TCP发送数据时, TCP将数据看作连续的字节流, 并将其分割成一个个的TCP数据段, 这些数据段在网络中传输可能会被拆分成多个IP分组。接收方需要将这些分组重新组装成原始的连续字节流。</li>
<li>UDP更适合一次性发送少量数据的应用场景, 如视频聊天, 实时游戏等</li>
<li>TCP更适合于需要可靠传输的大规模数据传输, 如文件下载, 电子邮件等</li>
</ol>
<blockquote>
<p>停止等待协议和连续ARQ协议的工作原理(可靠传输的工作原理)</p>
</blockquote>
<ul>
<li>停止等待协议: 一条一条的发送分组(接收到回复再发送下一条), 同时设置计时器; 收到则回复, 取消计时器; 反之不回复, 等待超时, 重新发送该分组; </li>
</ul>
<ol>
<li>发送方将数据按照一定的格式进行分组，并为每个分组设置一个序号。</li>
<li>发送方发送第一个分组，并开始计时器。计时器的作用是在规定时间内等待接收方的确认消息。如果超时未收到确认消息，则认为分组丢失，需要重新发送该分组。</li>
<li>接收方接收到数据后，确认收到该分组，并将确认消息发送给发送方。</li>
<li>发送方收到确认消息后，取消计时器，发送下一个分组。</li>
<li>如果接收方未能正确地接收到某个分组，则不发送确认消息，等待发送方超时后重传该分组。</li>
</ol>
<ul>
<li>连续ARQ协议: 一条一条的发送分组(类似滑动窗口, 无论是否接收到回复, 继续发送, 直到达到滑动窗口的极限), 设置计时器; 收到则回复期望的下一个, 取消计时器; 反之不回复, 等待超时, 重新发送</li>
</ul>
<ol>
<li>发送方将数据按照一定的格式进行分组，并为每个分组设置一个序号。</li>
<li>发送方发送多个分组，并开始计时器。计时器的作用是在规定时间内等待接收方的确认消息。</li>
<li>接收方接收到数据后，确认已经收到该分组，并将确认消息发送给发送方。确认消息中包含了接收方期望接收到的下一个分组的序号。</li>
<li>发送方收到确认消息后，将已经被确认的分组从缓存中删除，并按照接收方期望接收到的下一个分组的序号继续发送数据。</li>
<li>如果接收方未能正确地接收到某个分组，则不发送确认消息，等待发送方超时后重传该分组。</li>
</ol>
<blockquote>
<p>TCP可靠传输是如何实现的；</p>
</blockquote>
<p>TCP（传输控制协议）是一种面向连接、可靠的传输层协议，它使用一系列复杂的技术来保证数据的可靠传输。下面是TCP实现可靠传输的主要方法：</p>
<ul>
<li>校验 -&gt; 序号 -&gt; 确认 -&gt; 重传</li>
</ul>
<ol>
<li>确认号和序列号：TCP用确认号和序列号来保证数据传输的有序性和完整性。发送方将每个分组标记为一个唯一的序列号，并在接收方收到分组后，将确认号回复给发送方。这样可以确保所有的分组都能够按照正确的顺序被接收和处理。</li>
<li>应答机制：发送方将每个分组都标记为已发送并等待接收方的确认，如果接收方未能及时对分组进行确认，发送方会重新发送该分组。这样可以确保所有的分组都能够被成功传输。</li>
<li>超时重传机制：当发送方发送一个分组后，会启动一个计时器，并在计时器时间内等待接收方的确认。如果计时器超时，发送方会重新发送该分组。这样可以防止分组丢失或延迟过高而导致的数据丢失。</li>
</ol>
<ol>
<li>流量控制：TCP会根据接收方的处理速度和网络质量的变化，动态调整发送方的发送速率，以避免网络拥塞和资源浪费。</li>
<li>拥塞控制：通过检测网络的拥塞程度和调整发送窗口的大小，TCP可以有效控制网络拥塞和防止网络崩溃。</li>
</ol>
<blockquote>
<p>简述流量控制与拥塞控制的区别是什么；</p>
</blockquote>
<p>流量控制和拥塞控制是计算机网络中两个重要的控制技术，二者的区别如下：</p>
<ol>
<li><p>流量控制(<strong>滑动窗口实现</strong>)是为了保证数据发送方和接收方之间的<strong>数据传输速度匹配</strong>，防止接收方因处理不及时而导致数据丢失或缓存溢出，主要涉及到数据发送方和接收方之间<strong>控制数据流量大小</strong>的问题。</p>
<ul>
<li>让发送方的发送速率不要太快, 要让接收方来得及接受</li>
</ul>
</li>
<li><p>拥塞控制是为了保证网络中<strong>所有节点和链路的资源利用率合理</strong>，防止网络出现拥堵和过载，主要涉及到网络全局范围内<strong>调节数据传输速度</strong>的问题。</p>
<ul>
<li>防止过多的数据注入到网络中, 这样可以使网络中的路由器或链路不至于过载</li>
</ul>
</li>
</ol>
<p>因此，流量控制和拥塞控制的目标不同，虽然都是为了确保可靠性和效率，但流量控制更注重点对点的通信质量，而拥塞控制更注重整个网络的负载情况。</p>
<blockquote>
<p>TCP的拥塞控制方法有哪些；</p>
</blockquote>
<ol>
<li>慢开始: 在TCP连接建立时，初始拥塞窗口大小为一个较小的值，随着数据包的发送和接收，每经过一个往返时间RTT就将拥塞窗口大小加倍，直到达到一个阈值。</li>
<li>拥塞避免: 当拥塞窗口大小达到阈值之后，进入拥塞避免状态，在这个状态下每经过一个RTT，拥塞窗口大小增加一定量，如每次增加1个MSS（最大报文段长度），而不是像慢开始那样加倍。这种方式可以尽可能地利用网络资源，同时也能够避免网络拥塞。</li>
<li>快重传: 如果发送方连续收到三个重复的ACK（确认报文），就认为其中的一个数据包丢失了，立即重传该数据包，而不必等待超时计时器的触发。这样可以快速恢复因数据包丢失导致的拥塞状态。</li>
<li>快恢复: 在快重传的情况下，TCP会进入快恢复状态，此时将拥塞窗口大小减半，然后进入拥塞避免状态。这样可以避免因快速重传引起的网络拥塞。</li>
</ol>
<blockquote>
<p>TCP是如何建立连接的，画出TCP建立连接的过程图。</p>
</blockquote>
<ul>
<li>TCP连接传输的三个阶段: </li>
<li>连接建立(三次握手) -&gt; 数据传送 -&gt; 连接释放(四次挥手)</li>
</ul>
<p><img src="/posts/b9598422/三次握手0.png" alt="三次握手0"><br><img src="/posts/b9598422/三次握手.png" alt="三次握手"></p>
<p>SYN: 同步字段</p>
<ul>
<li>1: 表示建立连接的过程</li>
</ul>
<p>ACK: </p>
<ul>
<li>1: 确认的报文</li>
</ul>
<p>ack: 确认号</p>
<ul>
<li>ROUND1: 客户端发送<strong>连接请求报文段</strong>, 无应用层数据, <code>SYN = 1, seq = x(随机)</code></li>
<li>ROUND2: 服务端为该TCP连接<strong>分配缓存和变量</strong>, 并向客户端返回<strong>确认报文段</strong>, 允许连接, 无应用层数据, <code>SYN = 1, ACK = 1, seq = y(随机), ack = x + 1(严格按照上一个seq = x的基础上 + 1)</code></li>
<li>ROUND3: 客户端为该TCP连接<strong>分配缓存和变量</strong>, 并向服务器端返回确认的确认, 可以携带数据<code>ACK = 1, seq = x + 1, ack = y + 1(严格按照上一个seq = x的基础上 + 1)</code></li>
</ul>
<p>TCP连接释放的过程</p>
<p><img src="/posts/b9598422/四次挥手0.png" alt="四次挥手0"><br><img src="/posts/b9598422/四次挥手.png" alt="四次挥手"></p>
<p>FIN: 结束字段</p>
<ul>
<li>1: 释放连接</li>
<li>主动关闭TCP连接</li>
</ul>
<p>seq: 事件序号<br>ACK: 确认</p>
<h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><blockquote>
<p>论述IP地址、MAC地址、域名之间的区别；</p>
</blockquote>
<ol>
<li>IP地址属于虚拟地址, MAC地址属于物理地址, 两者作为反义词存在</li>
<li>MAC地址是数据链路层使用的地址, 而IP地址是网络层和以上各层使用的地址, 是一种逻辑地址</li>
</ol>
<p>IP地址、MAC地址和域名都是计算机网络中用于标识设备或服务的标识符。它们之间的区别在以下几个方面：</p>
<ol>
<li>IP地址：IP地址是用于在网络中唯一标识设备的数字地址。</li>
<li>MAC地址：MAC地址是用于在网络中唯一标识网络接口控制器的硬件地址。它由48位二进制数组成，通常表示为十六进制数，每个数占2个字节（例如00:1a:4b:5c:6d:7e）。MAC地址是固定的，与设备厂商相关，无法更改。</li>
<li>域名：域名是用于在互联网上标识特定网站的名称。</li>
</ol>
<blockquote>
<p>为什么要使用这些标识</p>
</blockquote>
<ul>
<li>这些标识符之所以使用是为了方便网络管理和通信。例如，IP地址可以用于路由数据包，并使设备在互联网上可寻址；MAC地址可以用于局域网内部通信和设备识别；域名可以使用户更容易访问网站。</li>
</ul>
<blockquote>
<p>它们之间通过什么协议进行转换</p>
</blockquote>
<ul>
<li>域名 -&gt; IP : DNS协议(域名系统协议)</li>
<li>IP -&gt; MAC : ARP协议(地址解析协议)</li>
</ul>
<blockquote>
<p>给定一个应用（例如：输入某网址，回车，页面呈现在显示器上），描述该过程是如何实现的，使用了哪些协议；</p>
</blockquote>
<p>当您在计算机上输入网址并按下回车键时，以下是整个过程的简要概述：</p>
<ol>
<li>域名解析：您的计算机首先需要将该网址转换为相应的 IP 地址。它会发送一个 DNS（Domain Name System）请求到本地 DNS 服务器或 ISP（Internet Service Provider）的 DNS 服务器以获取这个 IP 地址。</li>
<li>TCP 连接：一旦您的计算机得到了目标网站的 IP 地址，它会使用 TCP（Transmission Control Protocol）建立一个与目标服务器的连接。TCP 是一种可靠的协议，用于确保数据包在互联网上的可靠传输。</li>
<li>HTTP 请求：一旦 TCP 连接建立，您的浏览器会向目标服务器发送一个 HTTP（Hypertext Transfer Protocol）请求，该请求包含了您所请求的网页的 URL 和其他相关信息。</li>
<li>服务器处理请求：一旦服务器收到了您的 HTTP 请求，它会根据请求的内容来寻找相应的资源，并根据请求类型和参数来执行不同的操作（例如返回网页、进行搜索或者传送文件等）。</li>
<li>HTTP 响应：一旦服务器处理完您的请求，它会向您的浏览器返回一个 HTTP 响应，其中包含了请求资源的内容和其他相关信息。</li>
<li>显示网页：一旦您的浏览器收到了服务器的响应，它会根据内容类型和其他相关信息来正确地呈现网页，同时加载相关的资源文件（例如图片、CSS 文件或 JavaScript 文件等），以便完整地显示该网页。</li>
</ol>
<p>在这个过程中，主要使用了 DNS、TCP 和 HTTP 协议。其中，DNS 协议用于将域名转换为 IP 地址，TCP 协议用于建立可靠的连接和传输数据，HTTP 协议则用于请求和响应网络内容，并进行相应的处理。</p>
<blockquote>
<p>计算机网络都面临哪几种威胁，主动攻击和被动攻击的区别是什么，对于计算机网络，其安全措施有哪些；</p>
</blockquote>
<ol>
<li>被动攻击<ul>
<li>截获</li>
</ul>
</li>
<li>主动攻击<ul>
<li>篡改</li>
<li>恶意程序</li>
<li>拒绝服务</li>
</ul>
</li>
</ol>
<p>被动攻击: 窃取信息<br>主动攻击: 破坏系统</p>
<p>安全措施: <em>防火墙 </em>数据加密 <em>网络检测入侵 </em>网络安全漏洞扫描 <em>访问控制技术 </em>其他防范措施</p>
<blockquote>
<p>对称密钥密码体制和公钥密码体制的特点各是什么，各有何优缺点。</p>
</blockquote>
<ul>
<li>对称密钥密码体制: 加密密钥和解密密钥都是用相同密钥的密码体制<ul>
<li>优点: 速度快, 算法简单, 密钥短 </li>
<li>缺点: 安全性依赖于密钥管理, 密钥分发困难, 适用范围窄</li>
</ul>
</li>
<li>公钥密码体制: 使用不同的加密密钥和解密密钥, 又称非对称密钥密码体制<ul>
<li>优点: 安全性高, 密钥管理简单, 适用范围广</li>
<li>缺点: 处理速度较慢, 密钥长度长, 算法复杂</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛技巧</title>
    <url>/posts/777152b5/</url>
    <content><![CDATA[<h1 id="算法竞赛技巧"><a href="#算法竞赛技巧" class="headerlink" title="算法竞赛技巧"></a>算法竞赛技巧</h1><h2 id="防止最后卡空格-pta"><a href="#防止最后卡空格-pta" class="headerlink" title="防止最后卡空格(pta,,,)"></a>防止最后卡空格(pta,,,)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br></pre></td></tr></table></figure>
<p>*str = “ \n”;<br>解释:   当 i &lt; n, cout &lt;&lt; str[0]; ‘ ‘<br>        当 i == n, cout &lt;&lt; str[1]; ‘\n’</p>
<h2 id="竞赛缓解压力及做题顺序"><a href="#竞赛缓解压力及做题顺序" class="headerlink" title="竞赛缓解压力及做题顺序"></a>竞赛缓解压力及做题顺序</h2><ul>
<li>太紧张，可以吃一些东西，口香糖什么的，可以有效缓解压力</li>
<li>前两题较简单，看清题目，先做掉。</li>
<li>后面的题，若看很长时间了，仍然不会，打住！想暴力，那暴力分</li>
</ul>
<h2 id="防卡常"><a href="#防卡常" class="headerlink" title="防卡常"></a>防卡常</h2><ul>
<li>调用 <ctime> 函数库中的 clock()函数</ctime></li>
<li>clock()单位为 1e-6次方毫秒，1 clock() == 1e-6秒</li>
</ul>
<p>例子代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// clock()本身很慢，用 i%1000 == 0 来短路它避免频繁调用</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">clock</span>() - start &gt;= <span class="number">850000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>应试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>英语单词</title>
    <url>/posts/4c41b4ff/</url>
    <content><![CDATA[<h3 id="2023-6-22"><a href="#2023-6-22" class="headerlink" title="2023/6/22"></a>2023/6/22</h3><ul>
<li>convenient : adj. 方便的</li>
<li>convince : v. 使信服</li>
<li><p>conventional : adj. 墨守成规的, 传统的</p>
</li>
<li><p>facilitate : v. 促进, 使便利</p>
</li>
<li><p>facility : n. 设备</p>
</li>
<li><p>rarely : adv. 少见的</p>
</li>
<li><p>barely : adv. 几乎, 仅仅</p>
</li>
<li><p>reserve : v. 预定 -&gt; reserved : adj. 内敛的</p>
</li>
<li><p>reverse : v. 反转</p>
</li>
<li><p>subsequent : adj. 随后的, 后来的</p>
</li>
<li><p>substantial : adj. 大量的</p>
</li>
<li><p>shot : n. 尝试, 注射</p>
</li>
<li><p>shoot : v. 射击, 发射</p>
</li>
<li><p>illusion : n. 错觉, 幻想</p>
</li>
<li><p>illustrate : v. 说明, 表明</p>
</li>
<li><p>constitute : vlink(系动词). 组成, 构成</p>
</li>
<li><p>contribute : v. 捐献, 做贡献</p>
</li>
<li><p>boost : v. 增长</p>
</li>
<li><p>boast : v. 自夸, 自吹自擂</p>
</li>
<li><p>steady : adj. 稳定的 / 坚定的 -&gt; steadily : adv. 逐步地</p>
</li>
<li><p>stable : adj. 稳定的 / n.马厩 -&gt; stability : n. 稳定</p>
</li>
<li><p>pole : n. 杆子, 地极</p>
</li>
<li><p>pile : n. 一摞</p>
</li>
<li><p>field : n. 田, 地</p>
</li>
<li><p>yield : v. 出产, 产生</p>
</li>
<li><p>publish : v. 出版</p>
</li>
<li>polish : v. 擦光, 磨光</li>
</ul>
<h3 id="2023-6-23"><a href="#2023-6-23" class="headerlink" title="2023/6/23"></a>2023/6/23</h3><ul>
<li>patch : n. 小块, 斑点</li>
<li><p>pitch : n. 球场, 高音, 沥青</p>
</li>
<li><p>regulate : v. 管理, 约束</p>
</li>
<li><p>regular : adj. 有规律的, 频繁的</p>
</li>
<li><p>commit : v. 犯罪 / 忠心</p>
</li>
<li><p>commission : n. 委员会; v. 正式委托</p>
</li>
<li><p>conservation : n. 保护, 节约</p>
</li>
<li><p>conversation : n. 交谈, 谈话</p>
</li>
<li><p>treat : v. 治疗</p>
</li>
<li>retreat : v. 撤退</li>
</ul>
<h3 id="2023-6-24"><a href="#2023-6-24" class="headerlink" title="2023/6/24"></a>2023/6/24</h3><ul>
<li>rival : n. 对手</li>
<li><p>rural : adj. 向下的</p>
</li>
<li><p>slight : adj. 轻微的, 微小的</p>
</li>
<li><p>insight : n. 洞察力, 深刻见解</p>
</li>
<li><p>frequent : adj. 经常性的, 频繁的</p>
</li>
<li>fluent : adj. 流利的, 流畅的</li>
</ul>
<h3 id="2023-7-3"><a href="#2023-7-3" class="headerlink" title="2023/7/3"></a>2023/7/3</h3><ul>
<li>weird : adj. 古怪的, 奇异的</li>
<li><p>待定</p>
</li>
<li><p>element : n. 元素, 基本部分</p>
</li>
<li><p>elegance : n. 优雅, 典雅</p>
</li>
<li><p>outcome : n. 结果</p>
</li>
<li><p>overcome : v. 克服</p>
</li>
<li><p>weave : v. 编, 织</p>
</li>
<li><p>wave : n. 波浪</p>
</li>
<li><p>reserve : v. 预定</p>
</li>
<li><p>reverse : v. 反装</p>
</li>
<li><p>tale : n. 故事</p>
</li>
<li><p>tail : n. 尾巴</p>
</li>
<li><p>process : n. 进程, 过程</p>
</li>
<li><p>possess : v. 拥有, 具有 -&gt; possession : n. 个人财产</p>
</li>
<li><p>precise : adj. 精确的</p>
</li>
<li><p>precious : adj. 珍贵的</p>
</li>
<li><p>interpret  : v. 解释, 说明</p>
</li>
<li><p>interact : v. 相互沟通, 相互作用</p>
</li>
<li><p>justify : v. 证明</p>
</li>
<li><p>justice : n. 公平, 正义</p>
</li>
<li><p>dairy : n. 乳制品</p>
</li>
<li><p>daily : adj. 每天的</p>
</li>
<li><p>punish : v. 处罚, 惩罚</p>
</li>
<li>publish : v. 出版</li>
<li><p>polish : v. 擦光, 抛光</p>
</li>
<li><p>incident : n. 事件</p>
</li>
<li>accident : n. 事故</li>
</ul>
<h3 id="2023-7-4"><a href="#2023-7-4" class="headerlink" title="2023/7/4"></a>2023/7/4</h3><ul>
<li>session : n. 一场, 一节</li>
<li><p>待定</p>
</li>
<li><p>assess : v. 评估 -&gt; assesment : n. 评价</p>
</li>
<li><p>access : </p>
</li>
<li><p>route : n. 路线</p>
</li>
<li><p>routine : n. 惯例, 常规</p>
</li>
<li><p>phrase : n. 短语, 成语</p>
</li>
<li><p>phase : n. 阶段, 时期</p>
</li>
<li><p>shield : n. 盾牌</p>
</li>
<li><p>shed : v. 去除, 蜕皮, 流(血, 泪)</p>
</li>
<li><p>derive : v. 起源于</p>
</li>
<li><p>deserve : v. 值得</p>
</li>
<li><p>iron : n. 铁</p>
</li>
<li>steel : n. 钢</li>
</ul>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>英语单词</tag>
      </tags>
  </entry>
</search>
